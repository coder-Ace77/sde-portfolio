---
title: "1.Basics"
description: ""
date: "2026-02-05"
---



**Low-Level Design (LLD)** is a detailed phase in the software development process that focuses on designing the individual components outlined in the **High-Level Design (HLD)**. LLD delves into the specifics, defining how modules, classes, functions, and data structures interact to achieve the desired functionality.

For example, in a movie ticket booking system, LLD would detail how components like seat selection, payment processing, and ticket generation are implemented and interact with one another.

**High-Level Design (HLD)** focuses on the overall architecture of the system. For instance, in a movie ticket booking system, HLD would outline the main components like the user interface (where users select movies and seats), the backend services (handling booking requests, seat availability, and notifications), and the database (storing movie schedules, user data, and bookings).

It would also define how these components interactâ€”like the flow of data between the user interface, backend, and third-party payment gateways. 

Low-Level Design (LLD), on the other hand, dives into the specifics of implementing individual features. For example, it defines how the booking process worksâ€”detailing the step-by-step flow from when a user selects a movie and showtime to when a ticket is successfully booked.

It specifies how data is validated (e.g., ensuring selected seats are available and payment details are correct), algorithms for locking seats (to prevent double booking), and how the booking information is stored in the database (schema).Itâ€™s like creating blueprints for each transaction in the system, covering the smallest details to ensure reliability and precision.

LLD is described through detailed design artifacts that focus on the internal workings of each module. The documentation strives for **completeness** to minimize confusion during the coding phase.

LLD documentation typically includes:

1. **Component-Level Design:** Breaking down HLD modules into smaller, logical components.
2. **Class Diagrams:** Using **Unified Modeling Language (UML)** to show the structure of classes, their attributes, methods, and the relationships between them (inheritance, association, etc.).
3. **Behavioral Diagrams:** Diagrams like **Sequence Diagrams** (showing the order of interactions between objects for a specific task) or **Activity Diagrams** (showing the flow of control).
4. **Data Structures and Algorithms:** Specific choices for data structures (e.g., lists, maps, trees) and the detailed logic/algorithms (sometimes in **pseudocode**) used within key functions.
5. **Detailed Interface Specifications:** Exact definitions of APIs, including endpoint paths, request/response formats, and error codes.
6. **Design Principles and Patterns:** Application of principles like **SOLID** and the use of design patterns (e.g., Factory, Singleton, Observer) to ensure code quality, maintainability, and scalability.

Now understand that in lld interviews the idea is to have a working application which also supports the certain design patterns.

## Building blocks of lld

1. Requirement gathering
Understand the detailed requirements of the system. This includes identifying the functionality, constraints, and edge cases to ensure the design meets user needs. For example, in a movie ticket booking system, this would include functionality such as: ğŸ¥ğŸŸï¸

â—‹ Seat selection ğŸª‘
â—‹ Payment processing ğŸ’³
â—‹ Ticket generation ğŸ§¾
â—‹ Simultaneous bookings for the same seat ğŸ”„

2. Laying down use cases

Define specific scenarios that the system will handle, outlining inputs, actions, and expected outputs. Use cases help in clarifying the scope and guiding the design process. For a movie ticket booking system, use cases would include: ğŸ¬

â—‹ Booking tickets for a single user ğŸ‘¤
â—‹ Handling group bookings with seat proximity ğŸ‘¥
â—‹ Canceling a booking and refunding payment ğŸ’µ
â—‹ Sending notifications (SMS/email) for booking confirmation ğŸ“§ğŸ“±

3. **UML Diagrams:**

Create diagrams to visually represent the structure, behavior, and interactions of system components. In a movie ticket booking system, these could include: ğŸ“Š
â—‹ **Class Diagram:** Representing entities like User, Ticket, Movie, Payment, and Theater ğŸŸï¸ğŸ¬ğŸ’³ğŸ›ï¸
â—‹ **Sequence Diagram:** Showing the flow of actions for booking a ticket, including seat selection, payment processing, and confirmation ğŸ”„ğŸ’³
â—‹ **Activity Diagram:** Mapping the workflow for booking and canceling tickets ğŸ”ğŸ—“ï¸

4. Model problems
This phase focuses on solving specific problems identified during the use case analysis. It involves breaking down the system into smaller components and addressing individual design challenges. ğŸ’¡

Design patterns play a crucial role in this phase, offering reusable solutions to common design problems. Some of the most famous Design Patterns include:

â€¢ Factory Design Pattern ğŸ­
â€¢ Strategy Design Pattern ğŸ§ 
â€¢ Observer Design Pattern ğŸ‘€
â€¢ Singleton Design Pattern ğŸ”‘

Finally we write the code keeping in mind some other things -

Translate the design into clean, modular, and efficient code, adhering to coding standards and principles such as SOLID and DRY to ensure maintainability and scalability.