
---

SQL parts-

Data-definition language (DDL). The SQL DDL provides commands for defining relation schemas, deleting relations, and modifying relation schemas.

Data-manipulation language (DML). The SQL DML provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database.

Data query language (DQL)- To retrieve data from database. 

Transation control language(TCL)- To manage transations

Data control language (DCL)- To control access and permissions.

## DDL

SQL DDL is used to define set of relations and the information regarding each relation-

- The schema of a relation
- The types of values associated with each attribute.
- Integrity constraints
- Set of indices 
- Security and autherization
- Physical storage structure.

### Basic types

String types

|Data Type|Description|Example|
|---|---|---|
|`CHAR(n)`|Fixed-length string|`CHAR(10)`|
|`VARCHAR(n)`|Variable-length string|`VARCHAR(50)`|
|`TEXT`|Large text data|`TEXT`|
|`NCHAR(n)`|Fixed-length Unicode|`NCHAR(10)`|
|`NVARCHAR(n)`|Variable-length Unicode|`NVARCHAR(50)`|

Integer types

| Data Type      | Description        | Example         |
| -------------- | ------------------ | --------------- |
| `INT`          | Integer            | `INT`           |
| `SMALLINT`     | Smaller integer    | `SMALLINT`      |
| `BIGINT`       | Large integer      | `BIGINT`        |
| `DECIMAL(p,s)` | Exact decimal      | `DECIMAL(10,2)` |
| `NUMERIC(p,s)` | Same as DECIMAL    | `NUMERIC(8,3)`  |
| `FLOAT`        | Approximate number | `FLOAT`         |
| `DOUBLE`       | Double precision   | `DOUBLE`        |

Date type

|Data Type|Description|Example|
|---|---|---|
|`DATE`|Date only|`DATE`|
|`TIME`|Time only|`TIME`|
|`DATETIME`|Date + Time|`DATETIME`|
|`TIMESTAMP`|Date & time (timezone-aware in some DBs)|`TIMESTAMP`|
|`YEAR`|Year only|`YEAR`|

Boolean type

| Data Type          | Description   |
| ------------------ | ------------- |
| `BOOLEAN` / `BOOL` | TRUE or FALSE |

Binary type

|Data Type|Description|
|---|---|
|`BINARY(n)`|Fixed-length binary|
|`VARBINARY(n)`|Variable-length binary|
|`BLOB`|Binary Large Object|
Other types

|Data Type|Description|
|---|---|
|`ENUM`|One value from predefined list|
|`SET`|Multiple values from list|
|`JSON`|JSON formatted data|
|`UUID`|Unique identifier|
We define the SQL relation using create table command. 

```sql
create table <name>
(attr1_name attr1_type,
attr2_name attr2_type,
primary key(attr_name1,attr_name2));

create table <name>
(attr1_name attr1_type,
attr2_name attr2_type,
integrity c1,
integrity c2);
```

In the end we can define a list of intregity constraints. 
Primary key attributes are required to be unique and non null.

foreign key (Ak1 , Ak2 , . . . , Akn ) references s: The foreign key specification says that the values of attributes (Ak1 , Ak2 , . . . , Akn ) for any tuple in the relation must correspond to values of the primary key attributes of some tuple in relation s. Which means the value of refenrecing columns but be existing in referenced table. 

```sql
create table course(
course_name varchar(20),
instructor_name varchar(20),
course_id integer,
dept_id integer,
primary key(course_id),
foreign key (dept_id) references dept);
```

The constraints can also be written after the row definition and is called column level constraint. The constraint written in the end is called table level constraint. 

| Constraint Name | Syntax                           | Example                            |
| --------------- | -------------------------------- | ---------------------------------- |
| **PRIMARY KEY** | `col datatype PRIMARY KEY`       | `id INT PRIMARY KEY`               |
| **NOT NULL**    | `col datatype NOT NULL`          | `name VARCHAR(50) NOT NULL`        |
| **UNIQUE**      | `col datatype UNIQUE`            | `email VARCHAR(100) UNIQUE`        |
| **CHECK**       | `col datatype CHECK (condition)` | `age INT CHECK (age >= 18)`        |
| **DEFAULT**     | `col datatype DEFAULT value`     | `active BOOLEAN DEFAULT true`      |
| **FOREIGN KEY** | `col datatype REFERENCES t(col)` | `user_id INT REFERENCES users(id)` |

| Constraint Name        | Syntax                            | Example                                      |
| ---------------------- | --------------------------------- | -------------------------------------------- |
| **PRIMARY KEY**        | `PRIMARY KEY (c1, c2)`            | `PRIMARY KEY (order_id, product_id)`         |
| **UNIQUE**             | `UNIQUE (c1, c2)`                 | `UNIQUE (email, phone)`                      |
| **FOREIGN KEY**        | `FOREIGN KEY (c) REFERENCES t(c)` | `FOREIGN KEY (user_id) REFERENCES users(id)` |
| **CHECK**              | `CHECK (condition)`               | `CHECK (salary > 0)`                         |
| **CONSTRAINT (named)** | `CONSTRAINT name constraint`      | `CONSTRAINT chk_age CHECK (age >= 18)`       |



```sql
create table test(
id integer,
name varchar(20),
primary key (id),
not null name);
```

Drop table is used to delete a table from database. It removes the schema and table itself. It differes from delete from table which removes the rows only but keeps table intact. 

```sql
drop table test;
```

### Alter 

Alter table command is used to alter the attributes of a table. We can add columns , drop columns , add contraints, remove constraints etc. 

| Operation                   | Syntax                                                   | Example                                                       |
| --------------------------- | -------------------------------------------------------- | ------------------------------------------------------------- |
| **Add column**              | `ALTER TABLE t ADD COLUMN c datatype;`                   | `ALTER TABLE users ADD COLUMN email VARCHAR(100);`            |
| **Add column with default** | `ALTER TABLE t ADD COLUMN c datatype DEFAULT v;`         | `ALTER TABLE users ADD COLUMN active BOOLEAN DEFAULT true;`   |
| **Drop column**             | `ALTER TABLE t DROP COLUMN c;`                           | `ALTER TABLE users DROP COLUMN email;`                        |
| **Rename column**           | `ALTER TABLE t RENAME COLUMN old TO new;`                | `ALTER TABLE users RENAME COLUMN name TO full_name;`          |
| **Change column data type** | `ALTER TABLE t ALTER COLUMN c TYPE datatype;`            | `ALTER TABLE users ALTER COLUMN age TYPE BIGINT;`             |
| **Change type with cast**   | `ALTER TABLE t ALTER COLUMN c TYPE datatype USING expr;` | `ALTER TABLE users ALTER COLUMN age TYPE INT USING age::INT;` |
| **Set default value**       | `ALTER TABLE t ALTER COLUMN c SET DEFAULT v;`            | `ALTER TABLE users ALTER COLUMN active SET DEFAULT true;`     |
| **Drop default value**      | `ALTER TABLE t ALTER COLUMN c DROP DEFAULT;`             | `ALTER TABLE users ALTER COLUMN active DROP DEFAULT;`         |
| **Set NOT NULL**            | `ALTER TABLE t ALTER COLUMN c SET NOT NULL;`             | `ALTER TABLE users ALTER COLUMN email SET NOT NULL;`          |
| **Drop NOT NULL**           | `ALTER TABLE t ALTER COLUMN c DROP NOT NULL;`            | `ALTER TABLE users ALTER COLUMN email DROP NOT NULL;`         |
| **Rename table**            | `ALTER TABLE old RENAME TO new;`                         | `ALTER TABLE users RENAME TO app_users;`                      |

Constraints can also be added to the table

|Constraint|Syntax|Example|
|---|---|---|
|**Add primary key**|`ALTER TABLE t ADD CONSTRAINT name PRIMARY KEY (c);`|`ALTER TABLE users ADD CONSTRAINT users_pkey PRIMARY KEY (id);`|
|**Add foreign key**|`ALTER TABLE t ADD CONSTRAINT name FOREIGN KEY (c) REFERENCES t2(c);`|`ALTER TABLE orders ADD CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id);`|
|**Add unique**|`ALTER TABLE t ADD CONSTRAINT name UNIQUE (c);`|`ALTER TABLE users ADD CONSTRAINT uniq_email UNIQUE (email);`|
|**Add check**|`ALTER TABLE t ADD CONSTRAINT name CHECK (cond);`|`ALTER TABLE users ADD CONSTRAINT chk_age CHECK (age >= 18);`|
|**Drop constraint**|`ALTER TABLE t DROP CONSTRAINT name;`|`ALTER TABLE users DROP CONSTRAINT uniq_email;`|

### Basic structure of sql queries

The basic structure of an SQL query consists of three clauses: select, from, and where. The query takes as its input the relations listed in the from clause, operates on them as specified in the where and select clauses, and then produces a relation as the result. Now in real world database implementations the relation is considered a multiset to allow for the duplicate tuples. 

```sql
select <attr> from <table> where <pridcate>;

select name,age from users where points > 100;
```

We can also apply keywords in sql query which are placed before the attr names. Predicate is optional and defaults to true for all the cases. 

```sql
select distinct name from users;
select all name from users.
```

The select clause may also contain arithmetic expressions involving the operators +, −, ∗, and / operating on constants or attributes of tuples. 

```sql
select name,age*100 as new_age from users;
```

as here is a rename opertion for the table column name. 

### String opertions 

SQL strings are enclosed in the single quotes.`''`. Single quote in the string is wirtten as double quote. Equlaity opertion is =.
For example 
```sql
select * from dept where lower(dept_name)='Comp_sci';
```

| Operation            | Function / Operator | Syntax                        | Example                                    |
| -------------------- | ------------------- | ----------------------------- | ------------------------------------------ |
| Concat               | `CONCAT()`          | `CONCAT(s1, s2)`              | `CONCAT(first_name, last_name)`            |
| **Length**           | `LENGTH()`          | `LENGTH(str)`                 | `LENGTH('Adil')` → 4                       |
| **Uppercase**        | `UPPER()`           | `UPPER(str)`                  | `UPPER('adil')`                            |
| **Lowercase**        | `LOWER()`           | `LOWER(str)`                  | `LOWER('ADIL')`                            |
| **Substring**        | `SUBSTRING()`       | `SUBSTRING(str FROM s FOR l)` | `SUBSTRING('abcdef' FROM 2 FOR 3)` → `bcd` |
| **Substring**        | `LEFT()`            | `LEFT(str, n)`                | `LEFT('abcdef', 3)`                        |
| **Substring**        | `RIGHT()`           | `RIGHT(str, n)`               | `RIGHT('abcdef', 3)`                       |
| **Trim spaces**      | `TRIM()`            | `TRIM(str)`                   | `TRIM('  hi  ')`                           |
| **Left trim**        | `LTRIM()`           | `LTRIM(str)`                  | `LTRIM('  hi')`                            |
| **Right trim**       | `RTRIM()`           | `RTRIM(str)`                  | `RTRIM('hi  ')`                            |
| **Replace**          | `REPLACE()`         | `REPLACE(str, old, new)`      | `REPLACE('a-b-c', '-', ':')`               |
| **Position / Index** | `POSITION()`        | `POSITION(sub IN str)`        | `POSITION('b' IN 'abc')` → 2               |
| **Pattern match**    | `LIKE`              | `str LIKE pattern`            | `name LIKE 'A%'`                           |
| **Regex match**      | `~`                 | `str ~ regex`                 | `name ~ '^[A-Z]'`                          |
| **Split string**     | `SPLIT_PART()`      | `SPLIT_PART(str, delim, n)`   | `SPLIT_PART('a,b,c', ',', 2)`              |
| **Reverse**          | `REVERSE()`         | `REVERSE(str)`                | `REVERSE('abc')` → `cba`                   |
| **Pad left**         | `LPAD()`            | `LPAD(str, len, pad)`         | `LPAD('5', 3, '0')` → `005`                |
| **Pad right**        | `RPAD()`            | `RPAD(str, len, pad)`         | `RPAD('5', 3, '0')` → `500`                |
Like is used for pattern match. `%` evalutes to any string. So `%in%` will match the strings having in as substring.  Whereas `_` resolves to any character. Example this query evaluates to substring with more than three characters. `\` is used as excape character in pattern matching. eg `dept_name like '\%'`. We can also do mismatching by using not.

```sql
select * from dept where name like '___%'; 
select * from dept where name not like '___%';
```

Note: `*` means all attributes. 

We can order the display of tuples using order by clause. Order by can take many attributes as additional ordering columns. We have to use `asc/desc` to arrange the tuples in given ordering. 

```sql
select * from dept where lower(name) like "%science%" order by name asc;
```

Sql allows the use of logical connectives like `and,or,not` as connectives. The expression can have `<,>,<=,>=` etc as well. 

between is used for the ranges. 

```sql
select name from instructor where salary between 90000 and 100000;
```

Similarly not between also exist. 

#### Regex

Regex is used for string matching and is advanced version of like.

| Operator | Meaning                                 |
| -------- | --------------------------------------- |
| `~`      | Regex match (case-sensitive)            |
| `~*`     | Regex match (case-insensitive)          |
| `!~`     | Regex does NOT match                    |
| `!~*`    | Regex does NOT match (case-insensitive) |
```sql
SELECT 'Adil' ~ 'A.*';   -- true
SELECT 'adil' ~* 'A.*'; -- true
```

##### Basic building blocks

A literal character matches itself. 

```sql
SELECT 'hello' ~ 'ell'; -- true
```

`.` matches any single chacter. 

```sql
SELECT 'cat' ~ 'c.t'; -- true
```

character classes matches one character from the set 

```sql
[a-z]   → any lowercase letter
[A-Z]   → any uppercase letter
[0-9]   → any digit
```

```sql
SELECT 'apple' ~ '[a-z]+';  -- true
```

Classes can be combined

```sql
select user_name ~ '^[a-zA-Z0-9]+';
```

Predefined character classes

| Pattern | Meaning                   |
| ------- | ------------------------- |
| `\d`    | digit (`0-9`)             |
| `\w`    | letter, digit, underscore |
| `\s`    | whitespace                |
| `\D`    | non-digit                 |
| `\W`    | non-word                  |

```sql
SELECT 'A1' ~ '\w\d'; -- true
```

###### Quantifiers

They are used to define the repititions

| Symbol  | Meaning         |
| ------- | --------------- |
| `*`     | zero or more    |
| `+`     | one or more     |
| `?`     | zero or one     |
| `{n}`   | exactly n       |
| `{n,}`  | at least n      |
| `{n,m}` | between n and m |
```sql
SELECT 'aaa' ~ 'a+'; -- true
SELECT 'aa'  ~ 'a{2}'; -- true
```

Anchors define the position

| Anchor | Meaning         |
| ------ | --------------- |
| `^`    | start of string |
| `$`    | end of string   |
```sql
SELECT 'hello' ~ '^h'; -- true
SELECT 'hello' ~ 'o$'; -- true
```

Grouping `()` along with alteration `|` is used to groups patterns together. 

```sql
SELECT 'cat' ~ '(cat|dog)'; -- true
SELECT 'dog' ~ '(cat|dog)'; -- true
```

Full string validation

eg - 

Email regex

```sql
SELECT email
FROM users
WHERE email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
```

In postgres we can have exact match as follows 

```sql
SELECT REGEXP_MATCHES('abc123', '\d+'); returns only 123. AKA matching part
SELECT REGEXP_REPLACE('abc123', '\d+', 'XYZ'); outputs abcXYZ
```
### Set operations

Set operations can be used to operate on two different relation instance of same schema. Additionally they can applied on the results of two select queries. 

```sql
(select course id
from section
where semester = ’Fall’ and year= 2009)
union
(select course id
from section
where semester = ’Spring’ and year= 2010);
```

Union means the tuples in either of the relation is present in the resulting relation. 
The union operation automatically eliminates duplicates. To retain duplicates we use union all. 

Intersection mens picking only those tuples which are preset in both. 

Except is used for taking only those tuples from r1 which are not present in r2. All version also exist for both. 

```sql
r1 intersect r2;
r1 except r2;
```

### Set membership using in

The in connective tests for set membership, where the set is a collection of values produced by a select clause. The not in connective tests for the absence of set membership.

```sql
select * from dept where dept_id in (1,2,3);
```
#### Null values

The arithematic value of an xpression having null is null. The conditions pose a problem. So databases have third logical value called unknown. Now result of unknown is given as

and - false and unknown is false rest are unknown
or - true and unknown is true rest are unknown
not - not unknown is unknown

If the where clause predicate evaluates to either false or unknown for a tuple, that tuple is not added to the result.

### Integer and other operations

`ABS()` is used to give the absolute value of an integer. 

|Operation|Function|Syntax|Example|
|---|---|---|---|
|Ceiling|`CEILING()` / `CEIL()`|`CEIL(a)`|`CEIL(4.2)` → 5|
|Floor|`FLOOR()`|`FLOOR(a)`|`FLOOR(4.9)` → 4|
|Round|`ROUND()`|`ROUND(a)`|`ROUND(4.5)` → 5|
|Cast type|`CAST()`|`CAST(a AS INT)`|`CAST(4.9 AS INT)`|
|Cast type|`::`|`a::INT`|`4.9::INT`|

| Operation     | Function     | Syntax                      | Example                        |
| ------------- | ------------ | --------------------------- | ------------------------------ |
| Minimum       | `LEAST()`    | `LEAST(a, b)`               | `LEAST(10, 20)` → 10           |
| Maximum       | `GREATEST()` | `GREATEST(a, b)`            | `GREATEST(10, 20)` → 20        |
| Null handling | `COALESCE()` | `COALESCE(a, b)`            | `COALESCE(NULL, 5)`            |
| Conditional   | `CASE`       | `CASE WHEN cond THEN v END` | `CASE WHEN age>=18 THEN 1 END` |
SQL case is very usable in situations where data conversions to some label is required. case can operate after select as well as after the predicate. 

```sql
SELECT
    name,
    age,
    CASE
        WHEN age >= 18 THEN 'Adult'
        ELSE 'Minor'
    END AS status
FROM users;


SELECT
    name,
    score,
    CASE
        WHEN score >= 90 THEN 'Excellent'
        WHEN score >= 75 THEN 'Good'
        WHEN score >= 50 THEN 'Average'
        ELSE 'Fail'
    END AS result
FROM exams;

```

COALESCE is used to return the first non null value and can be used to handle null values. 

```sql 
select name,
		case 
			when coalesce(score,0)<=33 then 'Fail'
			else 'Pass'
		end as status
from exams;
```

### Date and time type in SQL

SQL has many date and time types. 

1. date - A calendar date containing a (four-digit) year, month, and day of the month.

```sql
date '2001-04-05'
```

2. time: The time of day, in hours, minutes, and seconds. A variant, time( p), can be used to specify the number of fractional digits for seconds (the default being 0). It is also possible to store time-zone information along with the time by specifying time with timezone. 
`
```sql
time '09:30:00'
```


3. timestamp: A combination of date and time. A variant, timestamp( p), can be used to specify the number of fractional digits for seconds (the default here being 6). Time-zone information is also stored if with timezone is specified.
```sql
timestamp ’2001-04-25 10:29:01.45’
```

We can use an expression of the form cast e as t to convert a character string (or string valued expression) e to the type t, where t is one of date, time, or timestamp. The string must be in the appropriate format as illustrated at the beginning of this paragraph. When required, time-zone information is inferred from the system settings.

| Type                                       | Description                   | Storage  | Example Value            |
| ------------------------------------------ | ----------------------------- | -------- | ------------------------ |
| `DATE`                                     | Calendar date (no time)       | 4 bytes  | `2026-01-04`             |
| `TIME`                                     | Time of day (no date)         | 8 bytes  | `14:35:20`               |
| `TIME WITH TIME ZONE`                      | Time with zone (rarely used)  | 12 bytes | `14:35:20+05:30`         |
| `TIMESTAMP`                                | Date + time (no timezone)     | 8 bytes  | `2026-01-04 14:35:20`    |
| `TIMESTAMP WITH TIME ZONE` (`timestamptz`) | Date + time in UTC internally | 8 bytes  | `2026-01-04 09:05:20+00` |
| `INTERVAL`                                 | Duration / time span          | 16 bytes | `2 days 3 hours`         |

| Function            | What It Returns             | Example                     |
| ------------------- | --------------------------- | --------------------------- |
| `CURRENT_DATE`      | Today’s date                | `2026-01-04`                |
| `CURRENT_TIME`      | Current time                | `14:35:20+05:30`            |
| `CURRENT_TIMESTAMP` | Date + time + timezone      | `2026-01-04 14:35:20+05:30` |
| `NOW()`             | Same as `CURRENT_TIMESTAMP` | same                        |
| `LOCALTIMESTAMP`    | Timestamp without timezone  | `2026-01-04 14:35:20`       |

Date and time aithematic

| Operation      | Syntax                 | Example Result                                         |
| -------------- | ---------------------- | ------------------------------------------------------ |
| Add days       | `date + INTERVAL`      | `DATE '2026-01-04' + INTERVAL '5 days'` → `2026-01-09` |
| Subtract dates | `date - date`          | `2026-01-10 - 2026-01-04` → `6 days`                   |
| Add hours      | `timestamp + INTERVAL` | `NOW() + INTERVAL '2 hours'`                           |
| Age difference | `AGE()`                | `AGE('2026-01-10','2026-01-04')`                       |

Extracting part

| Function                 | Extracts           | Example      |
| ------------------------ | ------------------ | ------------ |
| `EXTRACT(YEAR FROM ts)`  | Year               | `2026`       |
| `EXTRACT(MONTH FROM ts)` | Month              | `1`          |
| `EXTRACT(DAY FROM ts)`   | Day                | `4`          |
| `EXTRACT(HOUR FROM ts)`  | Hour               | `14`         |
| `EXTRACT(EPOCH FROM ts)` | Seconds since 1970 | `1704350120` |

Formatting

| Function                  | Purpose          | Example                                                 |
| ------------------------- | ---------------- | ------------------------------------------------------- |
| `TO_CHAR(ts, fmt)`        | Format output    | `TO_CHAR(NOW(),'YYYY-MM-DD HH24:MI')`                   |
| `TO_DATE(text, fmt)`      | Text → date      | `TO_DATE('04-01-2026','DD-MM-YYYY')`                    |
| `TO_TIMESTAMP(text, fmt)` | Text → timestamp | `TO_TIMESTAMP('04-01-2026 14:30','DD-MM-YYYY HH24:MI')` |

Comparison

```sql
WHERE order_ts >= TIMESTAMP '2026-01-01'
  AND order_ts <  TIMESTAMP '2026-01-11';
```
### SQL aggregate functions

Aggregate functions are functions that take a collection (a set or multiset) of values as input and return a single value.

SQL has five built in aggregate functions-

avg, min,max, sum , count

The input to sum and avg must be a collection of numbers, but the other operators can operate on collections of nonnumeric data types, such as strings, as well.

The aggregate when applied to the set of tuples / relations when result is a realtion with single tuple. 

```sql
select round(avg(dept_size),2) from dept;
```

If we do want to eliminate duplicates, we use the keyword distinct in the aggregate expression.

```sql
select count(distinct dept_name) from dept;
```

SQL does not allow the use of distinct with count `(*)`.It is legal to use distinct with max and min, even though the result does not change.

There are circumstances where we would like to apply the aggregate function not only to a single set of tuples, but also to a group of sets of tuples; we specify this wish in SQL using the group by clause. In general group by is ommited and entire relation is considered a single group. Group by can done based on multiple attributes and that means all the tuples with the given group by value will be forming a group. The where chaluse can still be applied the real difference comes with aggregate. Now the value of aggregate will not be a singleton relation rather multiple tuples will be part of it. 

```sql
select round(avg(dept_size),0) as dept_size_avg from dept group by dept_name;
```

When an SQL query uses grouping, it is important to ensure that the only attributes that appear in the select statement without being aggregated are those that are present in the group by clause.

At times, it is useful to state a condition that applies to groups rather than to tuples. This condition does not apply to a single tuple; rather, it applies to each group constructed by the group by clause. To express such a query, we use the having clause of SQL. SQL applies predicates in the having clause after groups have been formed, so aggregate functions may be used.

```sql
select round(avg(dept_size),0) as dept_size_avg from dept group by dept_name having avg(dept_size)>100;
```

As was the case for the select clause, any attribute that is present in the having clause without being aggregated must appear in the group by clause, otherwise the query is treated as erroneous.

## Query evaluation

1. from clause is first evaluated to form the relation or perform any necessary joins.
2. where clause is evaluated and tuples are filtered at this point.
3. tuples satisfying the where clause form the groups.
4. The having clause is then applied to each group, groups not satisfying the having are removed. 
5. The select clause uses the remaining groups to generate tuples of the result of the query, applying the aggregate functions to get a single result tuple for each group.

All aggregate functions except count `(*)` ignore null values in their input collection.

## Cartesian product and Joins

A typical sql query is like

```sql
select A1,A2,..
from r1,r2...
where P;
```

r1,r2 etc all are the relations.

A **Cartesian product** is the result of combining **every row of one table with every row of another table**.  
If table **A** has `m` rows and table **B** has `n` rows, the Cartesian product will contain **m × n rows**.

In SQL, a Cartesian product happens when:

- You use **multiple tables in FROM** without a join condition, or
- You explicitly use **CROSS JOIN**

```sql
SELECT *
FROM students
CROSS JOIN courses;
```

Implicit cartesian product

```sql
SELECT *
FROM students, courses;
```

A **JOIN** combines rows from two or more tables **based on a related column**. Unlike a Cartesian product, a JOIN **filters meaningful row combinations**.

Inner join Returns **only rows that match in both tables**. Inner join is also called natural join or simply join in tables. 

```sql
SELECT columns
FROM t1
INNER JOIN t2
ON condition;
```

```sql
SELECT s.name, c.course
FROM students s
INNER JOIN enrollments e ON s.id = e.sid
INNER JOIN courses c ON e.cid = c.cid;
```

INNER is optional and thus join and inner join are the same. 

`NATURAL JOIN` automatically joins tables by:
- Finding **all columns with the same name**
- Applying equality conditions on **all of them**
- Returning **only one copy** of those columns

Left inner join
Returns
- All rows from **left table**
- Matching rows from right table
- `NULL` if no match exists

```sql
SELECT *
FROM t1
LEFT JOIN t2
ON condition;

SELECT s.name, e.cid
FROM students s
LEFT JOIN enrollments e
ON s.id = e.sid;
```

Right outer join 

```sql
SELECT *
FROM students s
RIGHT JOIN enrollments e
ON s.id = e.sid;
```

Self join - joining table with itself

```sql
SELECT e.name AS employee, m.name AS manager
FROM employees e
LEFT JOIN employees m
ON e.manager_id = m.id;
```

Tricky eample 

```sql
select name, title
from instructor natural join teaches, course
where teaches.course id= course.course id;

%% is not same as %%

select name, title
from instructor natural join teaches natural join course;
```

as can be used to rename a realtion and is called correlation name in the SQL standards. 

## Nested subqueries

A subquery is a select-from-where expression that is nested within another query. A common use of sub-queries is to perform tests for set membership, make set comparisons, and deter-mine set cardinality, by nesting subqueries in the where clause. 

### set membership testing

SQL subquery will be done in where clause to find the set of values on which main query will be tested on.

```sql
select distinct course id
from section
where semester = ’Fall’and 
	year= 2009 and
	course_id in (select course id
	from section
	where semester = ’Spring’ and year= 2010);
```

```sql
select distinct name
from instructor
where name not in (’Mozart’, ’Einstein’);
```

#### Comparing two sets

We can compare two sets for example - 

Find the names of all instructors whose salary is greater than at least one
instructor in the Biology department.

The query can be written as - some actaully is used in place where atleast one is needed.

```sql
select name
from instructor
where salary > some (select salary
from instructor
where dept name = ’Biology’);
```
Note that we could also have compared the salary with min of `Biology` instructor. 
We can also use cartesian product for that as well.

```sql
select distinct T.name
from instructor as T, instructor as S
where T.salary > S.salary and S.dept name = ’Biology’;
```

Analogoes to some there is all as well

```sql
select name
from instructor
where salary > all (select salary
from instructor
where dept name = ’Biology’);
```

SQL includes a feature for testing whether a subquery has any tuples in its result. The exists construct returns the value true if the argument subquery is nonempty.

```sql
select course id
from section as S
where semester = ’Fall’ and year= 2009 and
exists (select *
from section as T
where semester = ’Spring’ and year= 2010 and
S.course id= T.course id);
```

### sub queries in the from clause

SQL allows a subquery expression to be used in the from clause. The key concept applied here is that any select-from-where expression returns a relation as a result and, therefore, can be inserted into another select-from-where anywhere that a
relation can appear.

```sql
select dept name, avg salary
from (select dept name, avg (salary) as avg salary
from instructor
group by dept name)
where avg salary > 42000;
```

We can give the subquery result relation a name, and rename the attributes, using the as clause, as illustrated below.

```sql
select dept name, avg salary
from (select dept name, avg (salary)
from instructor
group by dept name)
as dept avg (dept name, avg salary)
where avg salary > 42000;
```

### with clause

The with clause provides a way of defining a temporary relation whose definition is available only to the query in which the with clause occurs.

```sql
with max_budget (value) as(select max(budget) from department)
	select budget
	from department, max budget
	where department.budget = max budget.value;
```

The with clause defines the temporary relation max budget, which is used in the immediately following query. 

### scalar sub queries

SQL allows subqueries to occur wherever an expression returning a value is permitted, provided the subquery returns only one tuple containing a single attribute; such subqueries are called scalar subqueries.

```sql
select dept name,
	(select count(*)
	from instructor
	where department.dept name = instructor.dept name)
as num instructors
from department;
```

## Modification of database

### deletion

A delete request is expressed in much the same way as a query. We can delete only whole tuples; we cannot delete values on only particular attributes. SQL expresses a deletion by

```sql
delete from r1 where P;
```

The delete statement first finds all tuples t in r for which P(t) is true, and then deletes them from r. The where clause can be omitted, in which case all tuples in r are deleted. delete can only work on one relation but its where can be as complex as where of select query. 

### insertion

To insert data into a relation, we either specify a tuple to be inserted or write a query whose result is a set of tuples to be inserted.

The simplest insert statement is a request to insert one tuple.

```sql
insert into course values (’CS-437’, ’Database Systems’, ’Comp. Sci.’, 4);
```

In this example, the values are specified in the order in which the corresponding attributes are listed in the relation schema. For the benefit of users who may not remember the order of the attributes, SQL allows the attributes to be specified as
part of the insert statement.

```sql
insert into course (course id, title, dept name, credits)
values (’CS-437’, ’Database Systems’, ’Comp. Sci.’, 4);
```
 
More generally, we might want to insert tuples on the basis of the result of a query. Suppose that we want to make each student in the Music department who has earned more than 144 credit hours, an instructor in the Music department,
with a salary of $18,000.

```sql
insert into instructor select ID, name, dept name, 18000
from student where dept name = ’Music’ and tot cred > 144;
```

So the end can either be query or a tuple. 

```sql
insert into table (query | tuple);
```

Note that db has to evaluate the select fully before modifications and further addition does not get part of query. If that is allowed this query might create inf recursion

```sql
insert into test select * from test;
```

It is possible for inserted tuples to be given values on only some attributes of the schema. The remaining attributes are assigned a null value denoted by null.

### updates

In certain situations, we may wish to change a value in a tuple without changing all values in the tuple. For this purpose, the update statement can be used. As we could for insert and delete, we can choose the tuples to be updated by using a query.

```sql
update instructor set salary= salary * 1.05;
```

```sql
update table_name set attr1=val1 where P;
```

P can be as complex as where of select. val1 can be any scalar query or constant value. 

```sql
update instructor
set salary = case
when salary <= 100000 then salary * 1.05
else salary * 1.03
end
```

```sql
update student S
set tot cred = (
select sum(credits)
from takes natural join course
where S.ID= takes.ID and
takes.grade <> ’F’ and
takes.grade is not null);
```

## View

A **VIEW** is a **virtual table** whose data is not stored physically. Instead, a view stores a **SQL query**, and whenever the view is queried, that query is executed on the underlying base tables. Now a view is again a relation for all logical purposes.  So a view is first created and then can be queried just like a standard relation.

```sql
CREATE VIEW emp_public AS
SELECT id, name, department
FROM employees;
```

Using the view

```sql
SELECT * FROM emp_public;
```

View can act as-

- logical abstraction over complex queries.
- Act as a measure to hide the sensitive rows. 

Creating view

```sql
create view departments total_salary(dept_name, total_salary) as
select dept_name, sum(salary)
from instructor
group by dept name;
```

Now it can be queried according to the view

```sql
select dept_name from departments where total_salary>100000;
```

Note that it is optional to rename the attributes as earlier. 

Certain database systems(postgres) allow view relations to be stored, but they make sure that, if the actual relations used in the view definition change, the view is kept up-to-date. Such views are called materialized views.

Unlike a normal view:

A materialized view executes the query once
Saves the result set
Future queries read from this stored data, not from base tables.

To create materized view only MATERIZED keyword is added before the VIEW.

```sql
CREATE MATERIALIZED VIEW active_users_mv AS
SELECT * FROM users WHERE active = true;
```

## Transactions

A transaction consists of a sequence of query and/or update statements. The SQL standard specifies that a transaction begins implicitly when an SQL statement is executed.

Transaction rollback is useful if some error condition is detected during execution of a transaction.Commit is similar, in a sense, to saving changes to a document that is being edited, while rollback is similar to quitting the edit session without saving changes. Once a transaction has executed commit work, its effects can no longer be undone by rollback work. The database system guarantees that in the event of some failure, such as an error in one of the SQL statements, a power outage, or a system crash, a transaction’s effects will be rolled back if it has not yet executed commit work. In the case of power outage or other system crash, the rollback occurs when the system restarts.

Transactions are atomic meaning either all the statements will get executed or none will be eqecuted. 

Transactions have following four properties-

1. Atomicity - A transaction is **all or nothing**.

If any statement fails:
- PostgreSQL **rolls back**
- Database returns to its previous state

2. Consistency

A transaction always moves the database:
- From one **valid state**
- To another **valid state**
Constraints (PK, FK, CHECK, etc.) are always enforced.

 3. Isolation
 
Transactions do **not interfere** with each other.
Each transaction behaves **as if it is running alone**, depending on the isolation level.

3. Durability

Once committed:
- Changes are **permanent**
- Even system crashes won’t lose committed data

Now the general syntax of transactions

```sql

BEGIN
%% sql statements %%
COMMIT
```

Example

```sql
BEGIN;

-- Lock sender row
SELECT user_balance
FROM accounts
WHERE user_id = 1
FOR UPDATE;

-- Check balance
UPDATE accounts
SET user_balance = user_balance - 100
WHERE user_id = 1
  AND user_balance >= 100;

-- Ensure debit succeeded
-- (check row count in application)

UPDATE accounts
SET user_balance = user_balance + 100
WHERE user_id = 2;

COMMIT;
```

statement select for update exists to lock the row for the update during the transaction. Its a row level lock.
So that rows which are found after the select here will be locked. 

Single step atomic transfer. 

### Integrity constraints

We have seen that integrity constranits are created during table creation using create table method. 


#### Constraints on single table

- non null
- unique

```sql
create table test(id integer,name varchar(20),phone string,primary key(id),phone,name non null,unique(phone));
```

unique can additionally take multiple attributes. `unique(A1,A2)`

- check `<predicate>`

```sql
create table test(id integer,name varchar(20),phone string,primary key(id),phone,name non null,unique(phone),length(phone)=9);
```

#### Refrencial integrity

**Referential integrity** is a **conceptual rule** in relational databases. It means that a relationship between two tables must always remain valid. In simple terms, referential integrity ensures that a value in one table that refers to another table actually exists in that other table.

A **foreign key constraint**, on the other hand, is the **mechanism provided by the database** to enforce referential integrity. It is a **physical, declarative rule** defined at the schema level that tells the database engine how to maintain this relationship. When you declare a foreign key, the database automatically checks inserts, updates, and deletes to ensure that the relationship remains valid. In other words, a foreign key constraint is the **tool**, while referential integrity is the **goal**.

```sql
CREATE TABLE orders (
    order_id    SERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date  DATE NOT NULL,

    CONSTRAINT fk_customer
        FOREIGN KEY (customer_id)
        REFERENCES customers(customer_id)
        ON DELETE CASCADE
);
```

Note that contraint its name are optional and we can use 

```sql
CREATE TABLE orders (
    order_id INT,
    customer_id INT,
    order_date DATE,

    FOREIGN KEY (customer_id)
        REFERENCES customers(customer_id)
);
```

During transactions the integrity constraints are checked on all the steps. However sometimes we may require to check integrity after the last step only. A constraint can alternatively be specified as deferrable, which means it is checked immediately by default, but can be deferred when desired.

### Authorization

Authorization of following is possible in a db

- Read data
- insert data
- update data
- delete data

Each of these types of authorizations is called a privilege.

In addition to authorizations on data, users may also be granted authorizations on the database schema, allowing them, for example, to create, modify, or drop relations.

grant is used to give priveledges 

```sql
grant <prev list>
on <relation>
to <user/role>;

grant select on department to Amit, Satoshi;
```

The update authorization may be given either on all attributes of the relation or on only some.

```sql
grant update (budget) on department to Amit, Satoshi;
```

To revoke an authorization, we use the revoke statement. It is similar to grant

```sql
revoke <prev list>
on <relation>
from <user>;

revoke select on department from Amit, Satoshi;
```

A set of roles is created in the database. Authorizations can be granted to roles, in exactly the same fashion as they are granted to individual users. Each database user is granted a set of roles (which may be empty) that she is authorized to perform.





