# 3.Heaps

---

Usage of heaps in greedy problems -

The heaps are used in the greedy problems where we are required to implement the dynamic greedy strategies making the best local choice not just from a static array, but from a constantly changing set of candidates.

Patterns of problems -

- Regret strategy - This is the most "advanced" pattern. In standard greedy, you make a choice and never look back. In "Regret" greedy, you make a choice, but you keep track of your "worst" decision in a heap. If you later hit a constraint (e.g., run out of time/budget), you check if swapping the current option with a previous "expensive" choice yields a better result. Problem -  Course schedule III.
- Active manager - You need to manage a limited set of resources (rooms, servers, machines) against time-based tasks. The heap allows you to efficiently query "Who finishes earliest?
- Candidate pool - Sometimes you cannot simply "pick the best". You can only pick the best _among those you can afford_. As you "buy" items, you unlock new ones.  example ipo
- "Multi-Source" Competition (K-Way Merge) - You have multiple sorted lists (or generated sequences) and you need the "global" next smallest/largest element. This is essentially a "tournament" where the heap holds the current champion from each list.
- Dynamic Data Smoothing (Running Median) You need to maintain the "middle" of a dataset that is constantly growing. A single heap can't do this because it only gives you the extreme (min or max).

### 1. Kth largest element

### Solution

We can solve this problem by sorting the array but this will mean `O(nlogn)` complexity what we want is better compleixity. Now we maintain a heap of size atmost k. And this heap will be min heap meaning the top element will be smallest and so we can easily discard the smallest element and move forwanrd.

```java
class Solution {
    public int findKthLargest(int[] nums, int k){
        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->a-b);
        for(int num:nums){
            pq.add(num);
            if(pq.size()>k)pq.poll();
        }
        return pq.peek();
    }
}

```

### 2. IPO

You are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.
Initially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.
Pick a list of **at most** `k` distinct projects from given projects to **maximize your final capital**, and return _the final maximized capital_.

Solution-

The idea is that we can pick up the elements in the increasing order of capictal needed so that we will increase capital iteratively. Now suppose we know with the given money say `x` we can spend in following 10 projects. And the money req to do other projects is higher which project should be done. Obviously it should be the one with highest pay among 10 projects. As you do a poject we will have more money to spend so the 10 projects can grow to larger numbers say 20 or 30. That is the essence of greedy strategy here

```java
class Solution {
    public:
    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {
        int n = profits.size();
        vector<pair<int,int>> v;
        for(int i=0;i<n;i++){
            v.push_back({profits[i],capital[i]});
        }
        sort(v.begin(),v.end(),[&](pair<int,int> a,pair<int,int> b){
            return a.second<b.second;
        });
        int cnt = 0;
        int i=0;
        long long curr=w;

        priority_queue<int> pq;

        while(cnt<k){
            while(i<n && v[i].second<=curr){
                pq.push(v[i].first);
                i++;
            }
            if(pq.size()>0){
                int tp = pq.top();pq.pop();
                curr+=tp;
                cnt++;
            }else{
            break;
        }
    }
    return curr;
}
};

```

## Finding k pairs

You are given two integer arrays `nums1` and `nums2` sorted in **non-decreasingÂ order** and an integer `k`.

Define a pair `(u, v)` which consists of one element from the first array and one element from the second array.

Return _the_ `k` _pairs_ `(u1, v1), (u2, v2), ..., (uk, vk)` _with the smallest sums_.

Solution -

Note that we try to maintain the boundry of next feasible elements in the heap and then pick the smallest from boundry.

```java
class Solution {
    public:
    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        int m = nums1.size();
        int n = nums2.size();

        vector<vector<int>> ans;
        set<pair<int, int>> visited;

        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>,
        greater<pair<int, pair<int, int>>>> minHeap;
        minHeap.push({nums1[0] + nums2[0], {0, 0}});
        visited.insert({0, 0});

        while (k-- && !minHeap.empty()) {
            auto top = minHeap.top();
            minHeap.pop();
            int i = top.second.first;
            int j = top.second.second;

            ans.push_back({nums1[i], nums2[j]});

            if (i + 1 < m && visited.find({i + 1, j}) == visited.end()) {
            minHeap.push({nums1[i + 1] + nums2[j], {i + 1, j}});
            visited.insert({i + 1, j});
        }

        if (j + 1 < n && visited.find({i, j + 1}) == visited.end()) {
        minHeap.push({nums1[i] + nums2[j + 1], {i, j + 1}});
        visited.insert({i, j + 1});
    }
}

return ans;
}
};

```

### Finding median of data stream -

This problem is classical and hard one. Essentailly this comes in the paradigm of balancing the two data structures here heap for example -
So meadian is the middle most element of a multiset after sorting two heaps means we can maitain the sorted order such that middle most elements always remain on the top of heaps.

```java
class MedianFinder {
    public:
    priority_queue<int> pq1;
    priority_queue<int,vector<int>,greater<int>> pq2;
    int cnt=0;
    MedianFinder(){

    }

    void addNum(int num) {
        if(pq1.size()==0){
            pq1.push(num);
            cnt++;
            return;
        }
        if(num>pq1.top())pq2.push(num);
        else pq1.push(num);
        cnt++;
        if(cnt%2==0){
            if(pq1.size()>pq2.size()){
                pq2.push(pq1.top());
                pq1.pop();
            }else if(pq1.size()<pq2.size()){
            pq1.push(pq2.top());
            pq2.pop();
        }
    }
}

double findMedian() {
    if(cnt%2){
        if(pq1.size()>pq2.size())return pq1.top();
        else return pq2.top();
    }else{
    double sum = pq1.top()+pq2.top();
    return sum/2;
}
}
};

```
