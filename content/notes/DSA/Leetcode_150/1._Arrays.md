---
title: "1. Arrays"
description: ""
date: "2026-02-05"
---



#### 1. [Merge Sorted Arrays](https://leetcode.com/problems/merge-sorted-array/?envType=study-plan-v2&envId=top-interview-150)

You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

#### Solution:

Normal merging of two sorted arrays moves from start to end. To save space and merge in the same array we move backwards. We put the larger element first while moving from the end of the array.

```cpp
class Solution {
   public void merge(int[] nums1, int m, int[] nums2, int n) {
       int ptr = n+m-1 , i = m-1 , j = n-1;
       while(i>=0 && j>=0){
           if(nums1[i]>nums2[j])nums1[ptr--]=nums1[i--];
           else nums1[ptr--]=nums2[j--];
       }
       while(i>=0)nums1[ptr--]=nums1[i--];
       while(j>=0)nums1[ptr--]=nums2[j--];
   }

}
```

#### 2. [Romove the element](https://leetcode.com/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150)
Given an integer array nums and an integer val, remove all occurrences of val in nums [in-place](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.

Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:

- Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.
    
- Return k.

#### Solution:
Idea is to maintain additional pointer j which means array uptil [0,j-1] is valid(no ele with val). Now We can encounter two kinds of elements if we encounter val. Then move forward else with non val element we have to swap with jth element.

```cpp
class Solution{
public:
   int removeElement(vector<int>& nums, int val) {
       int i=0,j=0;
       int n = nums.size();
       while(i<n){
           if(nums[i]!=val){
               swap(nums[i],nums[j]);
               j++;
           }
           i++;
       }
       return j;
   }
};
```

#### 3. [Remove elemnet from sorted array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150):

Given an integer array nums sorted in non-decreasing order, remove the duplicates [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

- Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
    

Solution:

Suppose we are iterating over indexes at j and i represents the last index till which array is valid. Now for any element a[j] two cases are there if a[i]=a[j] this means this element was already used in the valid array so we don't need to add it to the valid part. If a[i]!=a[j] this means that ele was not used and must be added at i+1 th index.

```cpp
class Solution {
public:
   int removeDuplicates(vector<int>& nums) {
       int i=0;
       for(int j=1;j<nums.size();j++){
           if(nums[i]!=nums[j]){
               i++;
               nums[i]=nums[j];
           }
       }
       return i+1;
   }
};
```

#### 4. [Remove Duplicates 2](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150):
Given an integer array nums sorted in non-decreasing order, remove some duplicates [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears at most twice. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Solution:

Again the idea is same. Since we can keep atmost two element the condition to insert an element into valid subarray [0,i-1] is to check a[i-2]!=a[j] reason being if a[i-2]=a[j] this means for this a[j] atmost two of the entries are already inserted. So no need to insert other wise we can insert it at ith pos and increment the count.

```cpp
class Solution {
public:
   int removeDuplicates(vector<int>& nums) {
       int i=0;
       for(int j=0;j<nums.size();j++){
           if(i<=1 || nums[i-2]!=nums[j]){
               nums[i]=nums[j];
               i++;
           }
       }
       return i;
   }
};
```

#### 5. [Majority Element](https://leetcode.com/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150)

Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

Solution:

This is a famous majoirty problem. Idea is to keep a freq counter of the currently assumed majority element.

```cpp
class Solution {
public:
   int majorityElement(vector<int>& nums) {
       int ele=nums[0] , cnt = 0;
       for(auto e:nums){
           if(e==ele)cnt+=1;
           else{
               if(cnt>0)cnt--;
               else{
                   ele=e;
                   cnt=1;
               }
           }
       }
       return ele;
   }
};
```

Theorum: If the majority element is present only this element can be ele.

Proof: When we encounter an element either the freq of the element is increased or it decreases call it the balancing act. It is easy to see that if ele is majority all elements together can not balance it out. Thus in the end ele will reamin.

#### 6. [Rotate Array](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150):

Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.

Solution:

Right rotate:

```cpp
class Solution {
public:
   void rotate(vector<int>& nums, int k) {
       int n = nums.size();
       k %= n;
       reverse(nums.begin(), nums.end());
       reverse(nums.begin(), nums.begin()+k);
       reverse(nums.begin()+k, nums.end());
   }
};
```
  

Left Rotate: 

reverse first k element , then last n-k elements 
Finally all the elements must be reversed.

```python
def left_rotate(arr, d):
	n = len(arr)
	reverse(arr, 0, d - 1)
	reverse(arr, d, n - 1)
	reverse(arr, 0, n - 1)
```


Also right rotate:

```python
def right_rotate(arr, d):
	n = len(arr)
	d = d % n  # Handle if d > n
	reverse(arr, n - d, n - 1)
	reverse(arr, 0, n - d - 1)
	reverse(arr, 0, n - 1)
```

#### 7. [Best time to sell stocks](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-interview-150):

You are given an array prices where prices[i] is the price of a given stock on the ith day.
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.

Solution:

Max profit is max(a[i]-min(a[0,i-1])) - > aka we trty to sell on every day and to sell on day i we try to buy before ith day.

```cpp
class Solution {
public:
   int maxProfit(vector<int>& prices) {
       int mn = prices[0];
       int ans = 0;
       for(int i=0;i<prices.size();i++){
           ans = max(ans,prices[i]-mn);
           mn = min(mn,prices[i]);
       }
       return ans;
   }
};
```

Observing that greedy strategy like selling on the most expensive day won't work since it may happen that we may have to buy at a very high price. This strategy of trying to sell on every day while buy on cheapest day till possible is optimal.

#### 8. [Buy and sell stocks 2](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150);

You are given an integer array of prices where prices[i] is the price of a given stock on the ith day.
On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.
Find and return the maximum profit you can achieve.

Solution:

First observe that if we plot values on a graph we should buy at minima and sell at local maxima.
This profit is the sum of deltas of maxima - minima on increasing slope. This is again equivalent to the sum of deltas when the delta is positive. 
Which gives us most simplest code.

```cpp
class Solution {
public:
   int maxProfit(vector<int>& prices) {
       int profit = 0;
       for (int i = 1; i < prices.size(); i++) {
           int del = prices[i]-prices[i-1];
           if(del>0)profit+=del;
       }
       return profit;       
   }
};
```

#### 9. [Jump Game](https://leetcode.com/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150):

You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.

Return true if you can reach the last index, or false otherwise.

Solution:

Suppose it is known that we can reach upto index j. This means we can also reach upto any index `k<j`. Thus we can keep an index last_reach to hold this. If at any point we reach an index more than last_reach we can say this index is impossible to reach and if we can reach there may be we update last_reach to allow to reach some more indexes.

```cpp
class Solution {
public:
   bool canJump(vector<int>& nums) {
       int lst_index=0;
       for(int i=0;i<nums.size();i++){
           if(i>lst_index){
               return false;
           }else{
               lst_index = max(i+nums[i],lst_index);
           }
       }
       return true;
   }
};
```

#### 10. [Jump game 2](https://leetcode.com/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150):

You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].

Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:

- `0 <= j <= nums[i]` and
    
- `i + j < n`
    

Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].

Note it is very easy to come up with O(n^2) solution:(dp based)
```cpp
class Solution {
public:
   int jump(vector<int>& nums) {
       vector<int> dp;
       dp.push_back(0);
       int n = nums.size();
       for(int i=1;i<n;i++){
           int crr_min = INT16_MAX;
           for(int j=0;j<i;j++){
               if(j+nums[j]>=i){
                   crr_min = min(crr_min,dp[j]+1);
               }
           }
           dp.push_back(crr_min);
       }
       return dp[n-1];
   }
};
```

But infact we can come up with greedy O(n) solutions: The idea is to think in terms of jumps so say we maintain a range which says in j jumps what segment we can be in. [a,b] then we can calculate in what range we can be in for the next jump. Closest we can be is b+1 for jump j+1 and farthest can be figured out by seeing all possbile jumps. 

Since each cell is processed only once we get O(n) time and O(1) space complexity.

```cpp
class Solution {
public:
   int jump(vector<int>& nums) {
       int a=0,b=0,n=nums.size(),j=0;
       while(b<n-1){
           int farthest = b+1;
           for(int i=a;i<=b;i++){
               farthest = max(farthest,nums[i]+i);
           }
           a=b+1;
           b=farthest;
           j++;
       }
       return j;
   }
};
```

couple of points:
1. Question garantees that a solution exists so we can have a = b+1 aka next near position equal to current fartest+1. If this guarantee was not there this could not have been done. And we would have to resort to a dp solution.
2. It is clear that if we can reach pos x in jumps j then pos x-1 can also be reached in the same number or smaller number of jumps. This intuition justifies the validity of continous segment `[a,b]`.

#### 11. [H index](https://leetcode.com/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150):

Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.

According to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.

Solution:

There are two ways to do it:
a. Sorting: Reverse sort the array first. -> time complexity - O(nlogn)

```cpp
class Solution {
public:
   int hIndex(vector<int>& arr) {
       sort(arr.rbegin(),arr.rend());
       int ans=0;
       for(int i=0;i<arr.size();i++){
           if(arr[i]>=i+1)ans=i+1;
       }
       return ans;
   }
};
```

b. Counting: We can maintain the count of the number of papers having citations c. Observe that the maximum possble answer is n. Now what we can do is make an array of size n+1 and put the counts in this array. The reason for size n+1 is that all the papers with citation more than n won't increase the answer thus we can consider them having the citations n. Finally after counting we can find cumulative frequency and find the answer.

```cpp

class Solution {
public:
   int hIndex(vector<int>& arr) {
       int n = arr.size();
       vector<int> freq(n + 1, 0);
       for (int citation : arr) {
           freq[min(citation, n)]++;
       }
       int curr = 0;
       for (int i = n; i >= 0; i--) {
           curr += freq[i];
           if (curr >= i) {
               return i;
           }
       }
       return 0;       
   }
};
```

#### 12. [Insert Delete Getrandom](https://leetcode.com/problems/insert-delete-getrandom-o1/?envType=study-plan-v2&envId=top-interview-150):

Implement the RandomizedSet class:

- RandomizedSet() Initializes the RandomizedSet object.
    
- bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
    
- bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
    
- int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
    

You must implement the functions of the class such that each function works in average O(1) time complexity.

Solution:

The idea is to store values in array for random access and getting random element storing the actual index of elements in map.

```cpp
class RandomizedSet {
private:
   unordered_map<int, int> m;
   vector<int> l;
public:
   RandomizedSet() {
   }
   bool insert(int val) {
       if(m.count(val)!= 0) return false;
       m[val] = l.size();
       l.push_back(val);
       return true;
   }

   bool remove(int val) {
       if(m.count(val)!=0){
           int index = m[val];
           int lastvalue = l.back();
           l[index] = lastvalue;
           l.pop_back();
           m[lastvalue] = index;
           m.erase(val);
           return true;
       }
       return false;
   }

   int getRandom() {
       int randomIndex = std::rand() % l.size();
       return l[randomIndex];
   }
};
```

#### 13. [Product of array except Self](https://leetcode.com/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150):

Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.

Solution:

We can precal prefix sums and maintain sufffix sum while itering from back. prod[i] = pre[i-1]*curr_suff.

```cpp
class Solution {
public:
   vector<int> productExceptSelf(vector<int>& nums) {
       int n = nums.size();
       vector<int> pre(n);
       int curr=1;
       for(int i=0;i<n;i++){
           pre[i]=curr;
           curr*=nums[i];
       }
       curr=1;
       for(int i=n-1;i>=0;i--){
           pre[i]=curr*pre[i];
           curr*=nums[i];
       }
       return pre;
   }
```

In above implementation we have reused pre to strore answer.

#### 14 [Gas Station](https://leetcode.com/problems/gas-station/?envType=study-plan-v2&envId=top-interview-150):

There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.

Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.

Solution:

First, what is the condition of the existence of a solution. It is sum of gas>= sum of cost if that is true there will be atleast one index which gives us the correct answer. To prove this we can consider the delta[i]=gas[i]-cost[i] now since the sum of deltas >=0 there is some index starting from it every cumm delta has to be positive.

Once we know there is a solution, the problem isn’t too difficult since the solution is guaranteed to be unique.The main logic is to move the starting point to the current index + 1 whenever the gas falls below 0.

```cpp
class Solution {
public:
   int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
       int del=0;
       for(int i=0;i<gas.size();i++){
           del+=gas[i]-cost[i];
       }
       if(del<0)return -1;
       del=0;
       int ans=0;
       for(int i=0;i<gas.size();i++){
           del+=gas[i]-cost[i];
           if(del<0){
               del=0;
               ans=i+1;
           }
       }
       return ans;
   }
};
```

### Candy:

There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.

You are giving candies to these children subjected to the following requirements:

- Each child must have at least one candy.
- Children with a higher rating get more candies than their neighbors.

Return _the minimum number of candies you need to have to distribute the candies to the children_.

Solution:

This is a good greey solution and can have many approaches. First thing we noticed is that we will have condition of mountains and plateau. On the increasing slope we need to increase candies however as soon as plateau is reached we can give them all 1 candy. So miniumum candy to each one is 1. Now for the rest moving forward if prev current child has more rating we need to give it higher candy. This caters forward slopes but not reverse slopes. Imagine a mountain so on increasing slope form left and plateau all the values are correct but not on the descreaing slope. Observe that values only on this slope is false others are correct meaning we can just make them using same strategy. 

```cpp
class Solution {
	public:
	int candy(vector<int>& ratings) {
		int n=ratings.size();
		vector<int> ans(n,1);
		// left pass to correct values on increasing slope
		for(int i=1;i<n;i++){
			if(ratings[i]>ratings[i-1]){
				ans[i]=ans[i-1]+1;
			}else{
				ans[i]=1;
			}
		}
		// right pass to correct te values on descreaing slope
		for(int i=n-2;i>=0;i--){
			if(ratings[i]>ratings[i+1]){
				ans[i]=max(ans[i+1]+1,ans[i]);
			}
		}

		int sum=0;
		for(auto x:ans)sum+=x;
		return sum;
	}

};
```

There is a however a better solution than this with single pass and no additonal space.

The idea is keep the information about where we are either on upward slope or on downward slope or on plateau. 

If slope is increasing then we must increase candies, on platue candy resets to 1 and on downward slope the the candies descrease however we have to keep in mind that we may start on the peak of downward slope with too less candies and if slope is long enough we will have to increase the candies , so we also keep length of descending slope

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        int candies = 1;
        int up = 0, down = 0, peak = 0;

        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i-1]) {
                up++;
                peak = up;
                down = 0;
                candies += 1 + up;
            } else if (ratings[i] == ratings[i-1]) {
                up = down = peak = 0;
                candies += 1;
            } else { // ratings[i] < ratings[i-1]
                up = 0;
                down++;
                candies += 1 + down;
                if (down > peak) candies++; // adjust peak if needed
            }
        }
        return candies;
    }
};
```

### Trapping rain water - 

Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

Solution - 

There are many ways to solve this problem. Well simple observation is that we can fill the certain column upto minimum of max column on both sides. Because if we try to fill more water will get spilled from one of sides. Now important thing is that for each column we need max column on both the sides. 

Simplest solution will be to maintain the running maxima and build the max column array. This needs two passes one for precompute and other for actual compute.

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        vector<int> mx(n+1,0);
        for(int i=n-2;i>=0;i--){
            mx[i]=max(mx[i+1],height[i+1]);
        }

        int m=height[0];
        int ans=0;
        for(int i=1;i<n;i++){
            ans+=max(0,min(m,mx[i])-height[i]);
            m = max(m,height[i]);
        }
        return ans;
    }
};
```

However there is an another way. WIth one pass using two pointers only. The idea is like suppose at anypoint you have two extreme points l and r. Now if height of l is smaller then we can keep r as same and move l and updating the height. 

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int l = 0, r = n - 1;
        int ans = 0;
        int leftMax = 0, rightMax = 0;

        while (l < r) {
            if (height[l] < height[r]) {
                if (height[l] >= leftMax) {
                    leftMax = height[l];
                } else {
                    ans += leftMax - height[l];
                }
                l++;
            } else {
                if (height[r] >= rightMax) {
                    rightMax = height[r];
                } else {
                    ans += rightMax - height[r];
                }
                r--;
            }
        }
        return ans;
    }
}
```

### Roman to integer and integer to roman 

Roman numerals use letters like _I, V, X, L, C, D, M_ to represent values. Normally, roman digits are added from left to right, but a smaller value placed before a larger value represents subtraction. For example, _IV = 4_ because _I (1)_ comes before _V (5)_, and _IX = 9_ because _I_ comes before _X (10)_. The idea is to scan the string from left to right and compare each character with the next one. If the current value is less than the next value, it means this is a subtractive pair, so you subtract it from the answer. Otherwise, you simply add it. This single pass ensures you correctly interpret both normal cases like _XXVII = 27_ and subtractive cases like _XL = 40_ or _CM = 900_. In short, the logic is: **if curr < next → subtract**, otherwise **add**.

```java
class Solution {
public:
    int val(char ch){
        if(ch=='I')return 1;
        else if(ch=='V')return 5;
        else if(ch=='X')return 10;
        else if(ch=='L')return 50;
        else if(ch=='C')return 100;
        else if(ch=='D')return 500;
        else return 1000;
    }
    int romanToInt(string s) {
        int ans=0;
        for(int i=0;i<s.size();i++){
            int x = val(s[i]);
            if(i+1<s.size() && val(s[i])<val(s[i+1])){
                ans-=x;
            }else{
                ans+=x;
            }
        }
        return ans;
    }
};
```

To convert an integer to a Roman numeral, we use a greedy method because Roman numerals are built by repeatedly subtracting the largest possible symbol. First, we prepare a list of Roman symbols paired with their values, including the subtractive ones like _900 (CM)_, _400 (CD)_, _90 (XC)_, _40 (XL)_, _9 (IX)_, and _4 (IV)_. Then, starting from the largest value (_1000 = M_), we keep subtracting it from the number as long as possible and append the matching symbol to the output. Once that value can no longer fit, we move to the next largest value. This greedy approach always works because Roman numerals follow fixed hierarchical rules and the subtractive cases explicitly cover exceptions. By repeatedly subtracting the largest valid symbol, we generate the minimal and correct Roman representation.

```java
class Solution {
public:
    string intToRoman(int num) {
        const vector<pair<int, string>> valueSymbols{
            {1000, "M"}, {900, "CM"}, {500, "D"}, {400, "CD"}, {100, "C"},
            {90, "XC"},  {50, "L"},   {40, "XL"}, {10, "X"},   {9, "IX"},
            {5, "V"},    {4, "IV"},   {1, "I"}};

        string res;

        for (const auto& [value, symbol] : valueSymbols) {
            if (num == 0)
                break;

            while (num >= value) {
                res += symbol;
                num -= value;
            }
        }

        return res;        
    }
};
```

### Zigzag converion

The string `"PAYPALISHIRING"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R

And then read line by line: `"PAHNAPLSIIGYIR"`

Write the code that will take a string and make this conversion given a number of rows:


Solution -

Zigzag Conversion transforms a string by writing its characters diagonally across a given number of rows and then reading each row in order. The pattern moves downward row by row until it reaches the last row, then it reverses direction and moves upward diagonally, creating a zigzag motion. Imagine writing characters on a set of rows: you start at row 0, go down to row numRows - 1, then climb back up to row 0, repeating this cycle. Each character from the string is placed in the current row, and the direction—down or up—changes whenever you hit either the top or bottom row. After distributing all characters in this wave-like pattern, the final zigzag string is formed by concatenating all rows from top to bottom. This rearranges the characters based on their positions in the zigzag traversal, giving the converted output.

```java

class Solution {
    public String convert(String s, int numRows) {
        if(numRows==1)return s;
        StringBuilder[] grid = new StringBuilder[numRows];
        for (int i = 0; i < numRows; i++){
            grid[i] = new StringBuilder();
        }

        int n = s.length();
        int row=0;
        boolean down = true;
        for(int i=0;i<n;i++){
            grid[row].append(s.charAt(i));
            row = (down?row+1:row-1);
            if(row>=numRows){
                row=numRows-2;
                down=false;
            }else if(row<0){
                row=1;
                down=true;
            }
        }
        StringBuilder ans =  new StringBuilder();
        for(StringBuilder sb:grid){
            ans.append(sb.toString());
        }
        return ans.toString();
    }
}

```

### Text justification

Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly `maxWidth` characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left-justified, and no extra space is inserted between words.

#### Solution

```java

class Solution{
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth){
    
        int n = words.size();
        vector<string> ans;
        
        int i = 0; // pointer to traverse the words

        while (i < n){
        
            int j = i;
            int lineLength = 0, totalChars = 0;
            
            while (j < n && lineLength + words[j].length() + (j - i) <= maxWidth){
                lineLength += words[j].length(); 
                totalChars += words[j].length();
                j++;
            }

            int spaces = maxWidth - totalChars;
            int gaps = j - i - 1; 
            string line = "";

            if (j == n || gaps == 0) { 
                for (int k = i; k < j; k++) {
                    line += words[k];
                    if (k != j - 1) line += " ";
                }
                while (line.size() < maxWidth) line += " ";
            } else {
                int spaceEach = spaces / gaps;
                int extra = spaces % gaps; 

                for (int k = i; k < j; k++) {
                    line += words[k];
                    if (k != j - 1) {
                        int toAdd = spaceEach + (extra > 0 ? 1 : 0);
                        line += string(toAdd, ' ');
                        if (extra > 0) extra--;
                    }
                }
            }

            ans.push_back(line);
            i = j; 
        }

        return ans;
    }
};
```

### Find all numbers not in the array

Given an array `nums` of `n` integers where `nums[i]` is in the range `[1, n]`, return _an array of all the integers in the range_ `[1, n]` _that do not appear in_ `nums`. 

### Solution

The solution is pretty easy and straight forward if extra  space is allowed. 
To solve this question we intorduce cylic sort algorithm - It is used when array elements are `[1,n] n = array.size`. It can sort the array in `O(n)` time and `O(1)` space.  Instead of comparing elements, it places each number directly at its **correct index**.

Put every element where it **belongs**, not where it fits by comparison.” Note that since we know from begining where should an element end up at `index(x)=x-1` this means if we swap agfter each swap atleast one more element will reach its desired position what it means is that number of swaps is bounded by `O(n)`. 

General syntax - 

```cpp
for (int i = 0; i < n; ) {
	int idx = nums[i] - 1;
	if (nums[i] != nums[idx]) swap(nums[i], nums[idx]);
	else i++;
}
```

With this we can assume each element to be it specified position `arr[i]==i+1`. Now for this question we can just check if any element is not at its specified position that will be our answer. 

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; ) {
            int idx = nums[i] - 1;
            if (nums[i] != nums[idx]) swap(nums[i], nums[idx]);
            else i++;
        }

	    vector<int> ans;
	    for (int i = 0; i < n; i++)
	        if (nums[i] != i + 1) ans.push_back(i + 1);
        return ans;
    }
};
```

Another Solution- 

Since we just need some say to mark the element when we visit element x. To do that suppose when we reach `x` we can mark index `x-1` as negative. Finally all the elements corresponding to index(meaning element `x` if index `x-1`) is positive is not there. 

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            int idx = nums[i] - 1;
            nums[idx]*=-1;
        }

	    vector<int> ans;
	    for (int i = 0; i < n; i++)
	        if (nums[i]>0) ans.push_back(i+1);
        return ans;
    }
};
```