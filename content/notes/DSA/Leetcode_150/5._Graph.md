---
title: "5. Graph"
description: ""
date: "2026-02-05"
---



### Cloning graph

Given a reference of a node in a **connected** undirected graph.

Return a (clone) of the graph.

Each node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.

```
class Node {
    public int val;
    public List<Node> neighbors;
}
```

Solution - 

We maintain a map that links each original node to its cloned node. During DFS:

- If a node is already cloned, just return the clone.
- Otherwise, create a new node, store it in the map, and recursively clone all neighbors.
- This naturally handles cycles and avoids infinite loops.

```java
class Solution {
    public:
    
    Node* dfs(Node* cur,unordered_map<Node*,Node*>& mp){
        vector<Node*> neighbour;
        Node* clone=new Node(cur->val);
        mp[cur]=clone;
        for(auto it:cur->neighbors){
            if(mp.find(it)!=mp.end())neighbour.push_back(mp[it]); 
            else neighbour.push_back(dfs(it,mp));
        }
        clone->neighbors=neighbour;
        return clone;
    }

    Node* cloneGraph(Node* node){
        unordered_map<Node*,Node*> mp;
        if(node==NULL)return NULL;
        if(node->neighbors.size()==0){
            Node* clone= new Node(node->val);
            return clone; 
        }
        return dfs(node,mp);
    }
};
```

### Evaluate Division

You are given an array of variable pairs `equations` and an array of real numbers `values`, where `equations[i] = [Ai, Bi]` and `values[i]` represent the equation `Ai / Bi = values[i]`. Each `Ai` or `Bi` is a string that represents a single variable.
You are also given some `queries`, where `queries[j] = [Cj, Dj]` represents the `jth` query where you must find the answer for `Cj / Dj = ?`.
Return _the answers to all queries_. If a single answer cannot be determined, return `-1.0`.
**Note:** The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.
**Note:**Â The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.

### Solution 

The _Evaluate Division_ problem can be understood by modeling each variable as a node in a graph where each equation like `a / b = k` forms a directed edge from `a` to `b` with weight `k`, and another edge from `b` to `a` with weight `1/k`. Once this graph is built, each query becomes a path-search problem: to compute `x / y`, we simply look for any path from node `x` to node `y`. As we traverse the path, we multiply the edge weights along the way, because division relationships chain multiplicatively. If no such path exists, the answer is `-1.0`. DFS or BFS both work: start at the numerator variable, explore neighbors while carrying a running product, and stop when the denominator is reached. This approach works because division equations define a connected structure where ratios can be derived by following links, and the multiplicative nature of weights ensures that the final accumulated product represents the true ratio between any two connected variables. 

```java
class Solution {
    
public:
    unordered_map<string, vector<pair<string, double>>> graph;

    double dfs(string src, string dst, unordered_set<string>& visited, double product) {
        if (src == dst) return product;
        visited.insert(src);

        for (auto& [next, val] : graph[src]) {
            if (!visited.count(next)) {
                double res = dfs(next, dst, visited, product * val);
                if (res != -1.0) return res;
            }
        }
        return -1.0;
    }

    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        for (int i = 0; i < equations.size(); i++) {
            string a = equations[i][0], b = equations[i][1];
            double val = values[i];
            graph[a].push_back({b, val});
            graph[b].push_back({a, 1.0 / val});
        }

        vector<double> ans;
        for (auto& q : queries) {
            string u = q[0], v = q[1];
            if (!graph.count(u) || !graph.count(v)) {
                ans.push_back(-1.0);
                continue;
            }
            if (u == v) {
                ans.push_back(1.0);
                continue;
            }
            unordered_set<string> visited;
            ans.push_back(dfs(u, v, visited, 1.0));
        }
        return ans;
    }
};
```

### Course schedule 

There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.

- For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return `true` if you can finish all courses. Otherwise, return `false`.

#### Solution

There are many solution to this problem. First observe that if we form a graph of courses and directeced edges means course dependencies. The important point here is there is an order if and only if directed graph has no cycle. If no cycle then graph will have a topological ordering. 

Second solution is be removing all the leaf nodes. In directed graph leaf node means node with indeg 0. If we can repeatedly remove all the nodes by removing the leaf nodes then we will be done. This is one technique prevelant in cp for the problems of dependencies. 

Below code is the standard code to perform this simulation. We first start by putting all the node in the queue and then by simulation we reomve all the nodes one by one. As the nodes are moved all the nodes degrees are reduced if at any point we reach a node with degree = 0 we put in queue meaning it has to be deleted. 

```java
class Solution {
public:
    bool canFinish(int v, vector<vector<int>>& edge){

        int visited=0;
        vector<vector<int>>graph(v);
        vector<int>indegree(v,0);
        
        for(int i=0;i<edge.size();i++){
            int a = edge[i][0]; 
            int b = edge[i][1]; 
            graph[b].push_back(a);
            indegree[a]++;
        }
        queue<int>q;
        for(int i=0;i<v;i++){
            if(indegree[i]==0)q.push(i); 
        }
        while(q.size()){
            int curr=q.front();
            q.pop();
            visited++;
            for(auto neighbor:graph[curr]){
                indegree[neighbor]--;
                if(indegree[neighbor]==0)q.push(neighbor);
            }
        }
        if(visited==v)return true;
        else return false;
    }
};
```


If you want to find the order the same can be done as well with order infact the order will be bfs order. 

