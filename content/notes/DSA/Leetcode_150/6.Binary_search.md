---
title: "6.Binary search"
description: ""
date: "2026-02-05"
---



Searching in a given search space is one of the most practical ways to solve a given problem. In itself search is a paradigm and is very frequently used. Search space is defined as the set `S` where the given element can be found. In many problems in DSA/CP we can come up with a very niave search space. In most cases we can optise the entire search by focussing on either one of three- 

- Optimising the search algorithm 
- Reducing the search space 
- Using the property given to optimise the search space.

Simple binary search based on monotonic sorted arrays. 

The one important observation about this style of binary search is that after each iteration the range of search defined by `arr[low,high]` gets divided by half. Now if the range. So in the end in case of not finding the answer the  search `low=high+1.` Exactly which is when the loop terminates. 

### Binary search 

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

### Solution:

Note that what happens when the element is not found we return `low` as low will be pointing towards the just greater element. 

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int low = 0, high = nums.size()-1 , mid;
        while(low<=high){
            mid = (low+high)/2;
            if(nums[mid]==target)return mid;
            else if(nums[mid]>target){
                high = mid-1;
            }else{
                low = mid+1;
            }
        }
        return low;
    }
};
```

### Search in a 2d matrix 

You are given an `m x n` integer matrix `matrix` with the following two properties:

- Each row is sorted in non-decreasing order.
- The first integer of each row is greater than the last integer of the previous row.

Given an integer `target`, return `true` _if_ `target` _is in_ `matrix` _or_ `false` _otherwise_.

You must write a solution in `O(log(m * n))` time complexity.

### Solution

Since given that the rows are sorted and first element in the next row is larger than last element of previous row. This means entire 2d array can be considered 1D array of size `m*n`. Now we can find the row number and column number by division with number of columns. 

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size() , m = matrix[0].size();
        int low = 0 , high = n*m-1;
        while(low<=high){
            int mid = (low+high)/2;
            int r = mid/m , c = mid%m;
            if(matrix[r][c]==target){
                return true;
            }else if(matrix[r][c]<target)low = mid+1;
            else high = mid-1;
        }
        return false;
    }
}
```


### Peak element

A peak element is an element that is strictly greater than its neighbors.

Given a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.

You may imagine that `nums[-1] = nums[n] = -∞`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in `O(log n)` time.

### Solution 

Observe that given constraints guarantee that peak always exists and the reason is pretty simple. Now to find the peak one conditon can be 
`nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]`. However with this condition there is an issue of monotonicity. Better idea is to check the slope and move towards the upper side. 

For example `nums[mid]<nums[mid+1]` means we are on upward slope so we should move upwards. Otherwise we should move downwards. 

This `low` is guaranteed to be a peak because:

- If the slope was up, `low` moved upward to where the peak must be.
- If the slope was down, we moved `high` down, shrinking around the peak.
- Finally both pointers meet **exactly at a peak**.

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        if(nums.size()==1)return 0;
        int low=0,high = nums.size()-2,mid;
        while(low<=high){
            int mid = (low+high)/2;
            if(nums[mid]<nums[mid+1]){
                low=mid+1;
            }else{
                high=mid-1;
            }
        }
        return low;
    }
};
```

### Search in rotated sorted array

There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly left rotated** at an unknown index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be left rotated by `3` indices and become `[4,5,6,7,0,1,2]`.

Given the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

### Solution

Key idea is that in any rotated sorted array, **at least one half is always sorted**.

At every step:
1. You identify **one sorted half**.
2. You check whether the target lies within that sorted half.
3. If it does, you search inside that half using binary search.
4. If it doesn't, you search the other half.

And because you never discard the half where the target could logically be, you will eventually find the target or prove it does not exist.

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target){
        int low = 0 , high = nums.size()-1;
        while(low<=high){
            int mid = (low+high)/2;
            if(nums[mid]==target){
                return mid;
            }else if(nums[low]<=nums[mid]){
                if(nums[low]<=target && target<=nums[mid]){
                    high =  mid-1;
                }else{
                    low = mid+1;
                }
            }else{
                if(nums[mid]<=target && target<=nums[high]){
                    low = mid+1;
                }else{
                    high=mid-1;
                }
            }
        }
        return -1;
    }
};
```

### Find the minimum in rotated sorted array

Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:
- `[4,5,6,7,0,1,2]` if it was rotated `4` times.
- `[0,1,2,4,5,6,7]` if it was rotated `7` times.
Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.
Given the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.

### Solution

A rotated sorted array has two parts:

- A **sorted left part**
- A **sorted right part**
- The **minimum** is the rotation pivot—the point where the order breaks.

At any point, compare nums `mid` with nums `high`. This tells you which side contains the minimum. If `nums[mid]<=nums[high]` then right half is sorted so the peak can not be in right half. It has to be in left half. Similarly if left half is sorted then the then minimum has to be in the right half because the 

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int low=0,high = nums.size()-1;
        while(low<high){
            int mid = (low+high)/2;
            if(nums[mid]<=nums[high]){
                high=mid;
            }else{
                low=mid+1;
            }
        }
        return nums[low];
    }
};
```

### Median of two sorted arrays

Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

### Solution

This is the  **O(log(min(n, m))) binary search partition** algorithm for finding the median of two sorted arrays. Now the alorithm will partition the array into two halfs. Left half where every element of left in both array is smalller than every element on the right of both arrays. 

We want to **partition** the two arrays into:

Such that:

1. **Every element on the left is ≤ every element on the right**
2. The **left side contains exactly half** of the total elements.

If we find such a partition, the median is:

- If total is odd → **max(left side)**
- If even → **average of max(left) and min(right)**

Now if consider that `ith` element from first array is considered to be the split. Then where should the splitting point of second array will lie. It has to be at `(m+n+1)/2-i`. Now we check if this is valid split. If yes then correct. 

At partitiob we define the border as 

```cpp
leftA  = nums1[i-1]   (max element from left of nums1)
rightA = nums1[i]     (min element from right of nums1)
leftB  = nums2[j-1]
rightB = nums2[j]
```

If partition is not correct we can identify this by seesing if `leftA>rightB` then left is too big and neds to be adjusted. Similar for the other case.

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.size()>nums2.size())swap(nums1,nums2);
        int n = nums1.size(),m=nums2.size();
        int tot = n+m;
        int half = (n+m+1)/2;
        int low=0,high=n;
        while(low<=high){
            int mid = (low+high)/2;
            int i = mid;
            int j = half-mid;
            int leftA = (i<=0?-1e9:nums1[i-1]);
            int rightA = (i>=n?1e9:nums1[i]);
            int leftB = (j<=0?-1e9:nums2[j-1]);
            int rightB = (j>=m?1e9:nums2[j]);

            if(max(leftA,leftB)<=min(rightA,rightB)){
                if((n+m)%2==0){
                    return (max(leftA, leftB) + min(rightA, rightB)) / 2.0;
                }else{
                    return max(leftA,leftB);
                }
            }else if(leftA>rightB){
                high = mid-1;
            }else{
                low = mid+1;
            }
        }
        return 0.0;
    }
};
```