# 2. Sliding Window

---

Sliding window technique is used to solve the problems where it asked something about the subarrays. There are two paradigms of problems prevelent here -

1. Fixed size sliding window
2. Dynamic size sliding window

### Fixed size sliding window

Use when the subarray/substrString size **K is fixed**.Maintain a running window of size K. When window size exceeds K → remove left item.

```java
int l = 0, ans = 0, cur = 0;
for(int r = 0; r < n; r++){
    cur += a[r];
    if(r - l + 1 > k) cur -= a[l++];
    if(r - l + 1 == k) ans = max(ans, cur);
}

```

Although we were maintaining the sum here. In reality we can maintain any data structure like set, monotonic queue or even segment trees. The datastructure usually represnts the aggregate of entire thing.

### Fixed window with binary search

In problems there is an constraints on the validity in the sense that you are requried to find the max/min length subarray with given constraints. The idea is to binary search on the length of fixed window and then run the fixed size algorithm. In another type one can fix the value or answer and then run the fixed size sliding window based on the size

```python
left = smallest possible answer
right = largest possible answer

while (left < right) :
mid = (left + right) / 2

if check(mid):     // sliding window
right = mid    // mid is possible → try smaller
else:
left = mid + 1 // mid not possible → need bigger
return left

```

### Dynamic sliding window

Unlike the fixed window pattern, dynamic windows grow by moving the right pointer to include new elements and shrink by moving the left pointer to discard elements when constraints are violated. In these problems there is a concept of valid and invalid subarrarys. Now this technique can be applied to problems if and only if all the subarrays of valid array are valid. We call this kind of pattern validity argument.

Template

In reality curr can be any datastructure as long as validity argument is there. `l` and `r` are two pointers and answer represents the `answer` of the window at any point in time.

```java
int l = 0, cur = 0, ans = 0,r=0;
while(r < n){
    // adding an element to window window may be invalid at this point
    cur += a[r];

    while(cur > target) cur -= a[l++]; // condition inside while is the invalid condition.

    // window is valid here any query must be calc at this point

    ans = max(ans, r - l + 1);

    // updating right pointer any calc on the current window must be dome before this.
    r++;
}

```

The algorithm has time complexity fo `O(n)` because both left and right pointer move ony forward.
Note that we don't require the condition like `l<r` or something like that because there is an autostop condition.

Example -

Given an array of positive integers `nums` and a positive integer `target`, return _the **max length** of a_ subarray whose sum is less than or equal to`target`. If there is no such subarray, return `-1` instead.

Solution -

Again observe that validity of condition of subarray satisfies the validity argument. Baecause if some subarray of nums has sum atmost target then all its subarrays inside will also have sum atmost `target` observe this holds only for positive elements. If negative elements were here it would not have been allowed and we would have to use some other technique like binary search.

Example-

Given an array of positive integers `nums` and a positive integer `target`, return _the **minimal length** of a_ _whose sum is greater than or equal to_ `target`. If there is no such subarray, return `0` instead.

Solution -

This can be solved easily with binary search + fixed window approach.

Otherwise observe this problem does not follow valdity argument. So a subarray of a valid subarray is not valid. But observe that subarray of an invalid subarray is still valid. This is cmplementary validity argument that if the subarrays of invalid subarray is valid we can use this approach. The only thing one has to do is to caclculate answers inside the invalid  while loop.

```java
int l = 0, cur = 0, ans = 0,r=0;
while(r < n){
    // adding an element to window window may be invalid at this point
    cur += a[r];

    while(cur>=target){
        cur -= a[l++]; // condition inside while is the valid condition.
        ans = min(ans,r-l+1);
    }

    r++;
}

```

These are two important approaches to solve subarray problems.

#### Example -

Given a string `s`, find the length of the **longest** substring without duplicate characters.

```java
class Solution {

    private boolean check(Map<Character,Integer> mp){
        for(var e:mp.values()){
            if(e>1){
                return true;
            }
        }
        return false;
    }

    public int lengthOfLongestSubstring(String s) {
        Map<Character,Integer> mp = new HashMap<>();
        int n = s.length();
        int ans=0;

        int l=0,r=0;
        while(r<n){

            mp.put(s.charAt(r),mp.getOrDefault(s.charAt(r),0)+1);

            while(check(mp)){
                mp.put(s.charAt(l),mp.get(s.charAt(l))-1);
                l++;
            }
            ans = Math.max(ans,r-l+1);
            r++;
        }

        return ans;
    }
}

```

> [!NOTE] Tips
> Observe that these techniques solve the problems of constraints with atmost / alteast type to solve exact type we run same algorthim for two times. Atmost k+1 times and atmost ktimes and then subtract or something. for cnt problems.
> Sometimes it is easy to coplement the validity condition.
> Many validity conditon are realted to the count/ freq of something.
