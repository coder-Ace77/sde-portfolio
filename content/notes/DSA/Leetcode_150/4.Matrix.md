# 4.Matrix

---

### Spiral order:

Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.

![Alt](/img/Pasted_image_20251013062618.png)

We go boundary by boundary and move inwards. That is the essential operation. First row, last column, last row, first column, and then we move inwards by 1 and repeat. That's all. That is all the simulation that we need.

The idea is put up in the code as -

So four for loops each keeping track of the start row , start col and end row and end col. We move inward so for example for the start row we move from startcol to end col and that is it

```cpp
class Solution {
    public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> ans;
        int row = matrix.size();
        int col = matrix[0].size();
        int total = row * col;

        int srow = 0, scol = 0;
        int erow = row - 1, ecol = col - 1;
        int count = 0;

        while (count < total) {
            for (int i = scol; i <= ecol && count < total; i++) {
                ans.push_back(matrix[srow][i]);
                count++;
            }
            srow++;

            for (int i = srow; i <= erow && count < total; i++) {
                ans.push_back(matrix[i][ecol]);
                count++;
            }
            ecol--;

            for (int i = ecol; i >= scol && count < total; i--) {
                ans.push_back(matrix[erow][i]);
                count++;
            }
            erow--;

            for (int i = erow; i >= srow && count < total; i--) {
                ans.push_back(matrix[i][scol]);
                count++;
            }
            scol++;
        }

        return ans;
    }
};

```

### Rotating image y 90 inplace:

Observe that the rotation by 360 deg is same matrix itself. Roation by 90 deg is essentailly two steps and they can be done in any order

- Vertical flip along horizontal axis
- transpose

```cpp
void transpose(vector<vector<int>>& matrix){
    int n = matrix.size();
    for(int i = 0; i < n; i++){
        for(int j = 0; j < i; j++){
            swap(matrix[i][j], matrix[j][i]);
        }
    }
}

void reverseRows(vector<vector<int>>& matrix){
    for(int i = 0; i < matrix.size(); i++){
        reverse(matrix[i].begin(), matrix[i].end());
    }
}

void rotate(vector<vector<int>>& matrix) {
    transpose(matrix);
    reverseRows(matrix);
}

```

But why it works there are many things to note down here:

first is that rotation by 90 deg is equivalent to following transforation:
``new[c][n−1−r]=old[r][c]``

Which signifies that we need to have transpose as well as reversal of rows.

For rotating 180 deg there are many ways but first the mapping is `(r, c) → (n-1-r, n-1-c)` observe that this is equivalent to reversing each column then reversing each row

Finally for 270 deg we do a transpose and then reverse each column `(r, c) → (n-1-c, r)`

| Rotation | Mapping formula (clockwise) | Equivalent operations                  | Visual intuition                 |
| -------- | --------------------------- | -------------------------------------- | -------------------------------- |
| **90°**  | `(r, c) → (c, n-1-r)`       | Transpose → Reverse each row           | Turn right once                  |
| **180°** | `(r, c) → (n-1-r, n-1-c)`   | Reverse each row → Reverse each column | Upside down                      |
| **270°** | `(r, c) → (n-1-c, r)`       | Transpose → Reverse each column        | Turn right thrice (or left once) |

Note that these mappings are valid even for rectangle matrix but inplace is not possible as new matrix has different sizes.

### Set matrix to zero:

Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s.
Doing simple iteration going to each cell and then changing row and column is not a valid solution as we may get confused with weather it was original zero or not. Another way is to ark row by some number say which is not in matrix. However in this quesstion every number of interger range can come so its again not possbile.

Best solution is to go row wise. Suppose we arein first row now if i were to do row 0 meaning if 0 occurs in the row then we will change all values of this row to 0 is fine. Problem occurs with columns.

This solution sets entire rows and columns to zero in a matrix **in-place** without using extra space. It uses the first row and first column as markers: during the first pass, whenever a cell `(r, c)` is zero, it marks `matrix[r][0]` and `matrix[0][c]` as zero to indicate that the entire row `r` and column `c` should later be zeroed. Because the first column is used as a marker too, a boolean flag `zeroinFirstCol` tracks whether it originally contained a zero. In the second pass (traversing from bottom-right to top-left to avoid overwriting markers too early), each cell is set to zero if its row or column is marked. Finally, if `zeroinFirstCol` is true, the entire first column is set to zero. This achieves O(1) extra space and O(m×n) time complexity.

```cpp
void setZeroes(vector<vector<int>>& matrix) {
    bool zeroinFirstCol = false;
    int rows = matrix.size();
    int cols = matrix[0].size();

    for (int row = 0; row < rows; row++) {
        if (matrix[row][0] == 0) zeroinFirstCol = true;
        for (int col = 1; col < cols; col++) {
            if (matrix[row][col] == 0) {
                matrix[row][0] = 0;
                matrix[0][col] = 0;
            }
        }
    }

    for (int row = rows - 1; row >= 0; row--) {
        for (int col = cols - 1; col >= 1; col--) {
            if (matrix[row][0] == 0 || matrix[0][col] == 0)
            matrix[row][col] = 0;
        }
        if (zeroinFirstCol)
        matrix[row][0] = 0;
    }
}

```

### Game of life:

According to [Wikipedia's article](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life): "The **Game of Life**, also known simply as **Life**, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."

The board is made up of an `m x n` grid of cells, where each cell has an initial state: **live** (represented by a `1`) or **dead** (represented by a `0`). Each cell interacts with its [eight neighbors](https://en.wikipedia.org/wiki/Moore_neighborhood) (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

1. Any live cell with fewer than two live neighbors dies as if caused by under-population.
2. Any live cell with two or three live neighbors lives on to the next generation.
3. Any live cell with more than three live neighbors dies, as if by over-population.
4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

Given the current state of the `board`, **update** the `board` to reflect its next state.

We can update the board _in-place_ without extra memory by using temporary states. For example, `-1` to mark a cell that was alive but dies, and `2` for a cell that was dead but becomes alive. These transitional states still let us count live neighbors accurately.

Solution:

```cpp
#include <vector>
using namespace std;

class Solution {
    public:
    void gameOfLife(vector<vector<int>>& board) {
        int n = board.size();
        int m = board[0].size();

        vector<int> dx = {-1, -1, -1, 0, 0, 1, 1, 1};
        vector<int> dy = {-1, 0, 1, -1, 1, -1, 0, 1};

        // First pass: mark temporary state changes
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int live = 0;
                for (int d = 0; d < 8; d++) {
                    int ni = i + dx[d], nj = j + dy[d];
                    if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                        if (board[ni][nj] == 1 || board[ni][nj] == 2)
                        live++;
                    }
                }

                if (board[i][j] == 1) {
                    if (live < 2 || live > 3)
                    board[i][j] = 2; // live → dead
                } else {
                if (live == 3)
                board[i][j] = 3; // dead → live
            }
        }
    }

    // Second pass: finalize state updates
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (board[i][j] == 2) board[i][j] = 0;
            else if (board[i][j] == 3) board[i][j] = 1;
        }
    }
}
};

```

This algorithm updates the Game of Life **in-place** using encoded states to avoid losing original information mid-update. Each cell’s next state depends on the count of live neighbors (8 possible). To compute this without an auxiliary grid, the algorithm uses temporary markers:

- `2` means the cell was live (`1`) but will die (`0`).
- `3` means the cell was dead (`0`) but will become live (`1`).
During the first pass, it marks cells according to Conway’s rules:

- A live cell with fewer than 2 or more than 3 live neighbors dies.
- A dead cell with exactly 3 live neighbors becomes live.
Then, in the second pass, it finalizes transitions (`2 → 0`, `3 → 1`).
This achieves **O(1)** extra space and **O(m×n)** time complexity.

### Maximal square -

Well this is a dynamic programming problem. The answer for the max length square possbile for any square ending at cell `(i,j)` is

`max(dp[i-1,j-1],dp[i-1,j],dp[i,j-1])+1`.

```cpp
class Solution {
    public:
    int rec(int i,int j,vector<vector<char>>& mat,vector<vector<int>>& dp){
        int n = mat.size(),m=mat[0].size();
        if(i==n || j==m)return 0;
        if(i<0 || j<0)return 0;
        if(dp[i][j]!=-1)return dp[i][j];
        int ans=0;
        if(mat[i][j]=='1'){
            ans = max(ans,1+min({rec(i-1,j-1,mat,dp),rec(i,j-1,mat,dp),rec(i-1,j,mat,dp)}));
        }
        return dp[i][j]=ans;
    }

    int maximalSquare(vector<vector<char>>& matrix) {
        int n = matrix.size(),m=matrix[0].size();
        vector<vector<int>> dp(n,vector<int> (m,-1));
        int ans=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                ans = max(ans,rec(i,j,matrix,dp));
            }
        }
        return ans*ans;
    }
};

```
