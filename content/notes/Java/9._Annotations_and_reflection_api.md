---
title: "9. Annotations and reflection api"
description: ""
date: "2026-02-05"
---



Annotations are meta data meaning they provide information about the code that is not part of code itself. 

### Anatomy of annotation

When you define an annotation, you use the `@interface` keyword. It looks like an interface but behaves like a specialized object.

```java
public @interface Table {
    String name(); // This is a "member" or attribute
}
```

Annotation members can not have parameters `String name(int id)` is illegal. Return types are restricted to Primitives other annotations or array of these. We can provide the default as well `String name() default "generic table";` If a default is provided, the value is optional when using the annotation. 

Example 

```java
public @interface WebService {
    String name();                    // Required element
    String protocol() default "http"; // Optional element with default
    int port();                       // Required element
}
```

Meta annotations are the annotations about the annotations itself. Mainly 4 are important

|**Meta-Annotation**|**Purpose**|
|---|---|
|**`@Retention`**|Defines how long the annotation is kept. (`SOURCE`, `CLASS`, or `RUNTIME`).|
|**`@Target`**|Defines where the annotation can be applied (e.g., `METHOD`, `FIELD`, `TYPE`).|
|**`@Documented`**|Signals that the annotation should be documented by Javadoc.|
|**`@Inherited`**|Allows subclasses to inherit the annotation from a parent class.|

Using an annotation -

When you use an annotations in general we have to write like `key=value` syntax. 

```java
@WebService(name="Server1",protocol="udp",port=8080)
```

If annotation has one element named value() we can omit the name when applying the settings. 
If the annotation has no elements, it is called a "Marker Annotation": `@Override` or `@Deprecated`

Annotations do not do anything by themselves but they can allow other to do something for them For example compilers can check for the error by `@Override` annotation. Deployment tools can use it to generate boilder plate code. 

Most important use is the Runtime Reflection where we can use the `java.lang.reflect` API to read annotation values at runtime and change program behavior dynamically (common in frameworks like Spring or Hibernate).

To read annotations at runtime, you use Java's **Reflection API**. For an annotation to be visible during execution, its anatomy must include `@Retention(RetentionPolicy.RUNTIME)`. 

#### Example 

We want to Track the running time of method to do that we create an annotation.

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME) // Essential for Reflection
@Target(ElementType.METHOD)         // Can only be used on methods
public @interface TrackTime {
    String category() default "General";
}
```

Usage is pretty simple

```java
public class TaskProcessor {
    @TrackTime(category = "Database")
    public void saveData() {
        System.out.println("Saving data to DB...");
    }

    public void logActivity() {
        System.out.println("Logging activity...");
    }
}
```

Finally we need to define the engine that looks for metadata and acts on it. For example

```java
import java.lang.reflect.Method;

public class AnnotationRunner {
    public static void main(String[] args) throws Exception {
        TaskProcessor processor = new TaskProcessor();
        
        // 1. Get the Class object
        Class<?> clazz = processor.getClass();

        // 2. Iterate through all methods of the class
        for (Method method : clazz.getDeclaredMethods()) {
            
            // 3. Check if the specific annotation is present
            if (method.isAnnotationPresent(TrackTime.class)) {
                
                // 4. Extract the annotation instance
                TrackTime annotation = method.getAnnotation(TrackTime.class); 
                
                System.out.println("Found annotated method: " + method.getName());
                System.out.println("Category: " + annotation.category());
                
                // 5. Logic: Execute the method (optional)
                method.invoke(processor);
            }
        }
    }
}
```

Using relfection api we can at runtime get at the run time if annotation is present in a given object or class. Then we can extract the value from it and finally run on the method. 

## Java reflection api 

Java Reflection is the "magic" that makes frameworks like Hibernate, Spring, and JUnit possible. It allows a running Java program to **examine itself**—to look at its own classes, fields, and methods—and anipulate them at runtime, even if they are marked `private`.

In Java, every type (Class, Interface, Enum) is represented by an instance of `java.lang.Class`. This object contains the "blueprint" of your class. 

There are three ways to get the `Class` object:
1. **From a class name:** `Class<User> clazz = User.class;`
2. **From an instance:** `User myUser = new User(); Class<?> clazz = myUser.getClass();`
3. **From a string (Dynamic):** `Class<?> clazz = Class.forName("com.myapp.models.User");`

The `<?>` is a **Generics Wildcard**. It means "A Class of _unknown_ type."

### Field

Now once class is there we can simple get the fields inside class. Field is the member of `java.lang.reflect.Field`. When you use Reflection, a "Field" is no longer just a line of code; it is an **object itself**. The `java.lang.reflect.Field` class is a container that holds metadata about a specific variable in your class.

```java
Field field = clazz.getDeclaredField("username");
field.setAccessible(true); // The "Skeleton Key"

// Reading the value from an object instance 'user'
Object value = field.get(user); 

// Writing a value back into 'user'
field.set(user, "new_username");
```

There are two ways to get the fields - `getField()` or `getDeclaredField()`.  After this we have many operations which can be done on a field.

| **Method**                          | **Purpose**                                                              |
| ----------------------------------- | ------------------------------------------------------------------------ |
| **`getName()`**                     | Returns the name of the field as a String.                               |
| **`getType()`**                     | Returns a `Class` object representing the data type (e.g., `int.class`). |
| **`get(Object obj)`**               | Grabs the current value of this field from a specific object instance.   |
| **`set(Object obj, Object value)`** | Updates the value of this field on a specific object.                    |
| **`setAccessible(true)`**           | The "Master Key"—allows you to access and modify `private` fields.       |

### Method

In Java Reflection, a **Method** is a class (specifically `java.lang.reflect.Method`) that acts as a "functional blueprint." Just like the `Field` class represents a variable, the `Method` class represents a behavior or an action.When you hold a `Method` object, you aren't just holding the name of a function; you are holding the power to **execute** (invoke) that function on any instance of the class.

A `Method` object is a container that stores the following structural data:

|**Component**|**Description**|**Reflection Call**|
|---|---|---|
|**Name**|The identifier (e.g., `calculateTotal`).|`method.getName()`|
|**Return Type**|The `Class` type it returns (e.g., `void.class`, `int.class`).|`method.getReturnType()`|
|**Parameters**|An array of types it accepts as input.|`method.getParameterTypes()`|
|**Exceptions**|An array of checked exceptions it might throw.|`method.getExceptionTypes()`|
|**Modifiers**|Integers representing `public`, `static`, `final`, etc.|`method.getModifiers()`|

The most important part of the Method anatomy is the **`.invoke()`** method. This is how you tell the JVM to actually run the code.

The syntax for `.invoke()` is:

```java
method.invoke(objectInstance, argument1, argument2, ...);
```

Example-

```java
import java.lang.reflect.Method;

public class SmartHome {
    public void setTemperature(int degrees, String unit) {
        System.out.println("Setting AC to " + degrees + " " + unit);
    }
}

// Inside your Processor/Main:
SmartHome myHome = new SmartHome();
Class<?> clazz = myHome.getClass();

// 1. Find the method by name and its parameter signature
Method method = clazz.getDeclaredMethod("setTemperature", int.class, String.class);

// 2. Execute it
method.invoke(myHome, 22, "Celsius");
```

Note that we need to understand where certain function makes sence. For example the `field.getName()` makes sence for the class. However the `method.invoke()` does not makes sense without an alive instance. Most of the times it is pretty evident. 

For example with static method we don't need an instanace so we pass first arg as null. 

Finally the reflection api has contructor as another component. They can be used to create the objects at runtime. 

 Reflection is around 2-10 times slower than normal Java code as no inline code or compilation can  be done. 
Secondly there is reduced securioty as we can by pass encapsulation. Making private field accessible outside. 

### Dynamic proxies

In the standard Java world, if you want an object to perform a task, you write a `.java` file, compile it to a `.class` file, and instantiate it.

A **Dynamic Proxy** flips this on its head. It allows you to create an object **at runtime** that implements one or more interfaces, without you ever having to write the implementation class yourself.

Example using constructors to get the object. 

```java
T instance = clazz.getDeclaredConstructor().newInstance();
```

Example 

```java
import java.lang.reflect.*;

// 1. The Interface
interface OrderService {
    void placeOrder(String item);
}

// 2. The Real Implementation
class OrderServiceImpl implements OrderService {
    public void placeOrder(String item) {
        System.out.println("Processing order for: " + item);
    }
}

// 3. The Handler (The "Brain")
class LoggingHandler implements InvocationHandler {
    private final Object target; // The real object we are wrapping

    public LoggingHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(">>> LOG: Calling method " + method.getName());
        
        // Execute the actual method on the real object
        Object result = method.invoke(target, args);
        
        System.out.println(">>> LOG: Finished method " + method.getName());
        return result;
    }
}

public class ProxyDemo {
    public static void main(String[] args) {
        OrderService realService = new OrderServiceImpl();
        
        // Create the Proxy
        OrderService proxyInstance = (OrderService) Proxy.newProxyInstance(
            OrderService.class.getClassLoader(),
            new Class<?>[] { OrderService.class },
            new LoggingHandler(realService)
        );

        // Call the proxy
        proxyInstance.placeOrder("Laptop");
    }
}
```

