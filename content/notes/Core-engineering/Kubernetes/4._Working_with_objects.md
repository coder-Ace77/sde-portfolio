---
title: "4. Working with objects"
description: ""
date: "2026-02-05"
---



The `kubectl` tool supports verb-driven commands for creating some of the most common object types. The commands are named to be recognizable to users unfamiliar with the Kubernetes object types.

`run`: Create a new Pod to run a Container.
`expose`: Create a new Service object to load balance traffic across Pods.
`autoscale`: Create a new Autoscaler object to automatically horizontally scale a controller, such as a Deployment.

The `kubectl` tool also supports creation commands driven by object type. These commands support more object types and are more explicit about their intent, but require users to know the type of objects they intend to create.

`create <objecttype> [<subtype>] <instancename>`

Some objects types have subtypes that you can specify in the `create` command. For example, the Service object has several subtypes including ClusterIP, LoadBalancer, and NodePort. Here's an example that creates a Service with subtype NodePort:

```shell
kubectl create service nodeport <myservicename>
```

The `kubectl` command supports verb-driven commands for some common update operations. 

- scale -  Horizontally scale a controller to add or remove Pods by updating the replica count of the controller.

Most of the resources are named this way. So any deployment is named in this way. 

```sh
kubectl scale --replicas=5 deployment/web-deployment 
```

- `label`: Add or remove a label from an object.

The `kubectl` command also supports update commands driven by an aspect of the object. Setting this aspect may set different fields for different object types:

- `set` `<field>`: Set an aspect of an object.

We can also delete the objects using imperitive commands. 

```shell
kubectl delete deployment/nginx
```

There are several commands for printing information about an object:

- `get`: Prints basic information about matching objects. Use `get -h` to see a list of options.
- `describe`: Prints aggregated detailed information about matching objects.
- `logs`: Prints the stdout and stderr for a container running in a Pod.

|**General Syntax**|**Example**|**What it does**|
|---|---|---|
|`kubectl apply -f <filename>`|`kubectl apply -f nginx-deploy.yaml`|**Creates or updates** resources defined in a YAML file (the "Declarative" way).|
|`kubectl get <resource>`|`kubectl get pods`|Lists all resources of that type in the current namespace.|
|`kubectl describe <resource> <name>`|`kubectl describe pod my-nginx`|Shows **detailed information** and event logs for a specific resource (great for debugging).|
|`kubectl delete <resource> <name>`|`kubectl delete service web-service`|Removes the specified resource from the cluster.|

| **General Syntax**                                        | **Example**                                     | **What it does**                                                           |
| --------------------------------------------------------- | ----------------------------------------------- | -------------------------------------------------------------------------- |
| `kubectl scale --replicas=<num> <type>/<name>`            | `kubectl scale --replicas=5 deployment/api`     | Manually changes the **number of pods** running for a deployment.          |
| `kubectl rollout status <type>/<name>`                    | `kubectl rollout status deploy/web`             | Checks the progress of a rolling update to see if it succeeded.            |
| `kubectl rollout undo <type>/<name>`                      | `kubectl rollout undo deploy/web`               | **Rolls back** to the previous version of a deployment if an update fails. |
| `kubectl set image <type>/<name> <container>=<new-image>` | `kubectl set image deploy/web nginx=nginx:1.23` | Updates the container image, triggering a rolling update.                  |

| **General Syntax**                         | **Example**                     | **What it does**                                                            |
| ------------------------------------------ | ------------------------------- | --------------------------------------------------------------------------- |
| `kubectl logs <pod-name>`                  | `kubectl logs auth-pod`         | Prints the **stdout/stderr logs** from the containers inside the pod.       |
| `kubectl logs -f <pod-name>`               | `kubectl logs -f auth-pod`      | Streams logs in **real-time** (follows the log).                            |
| `kubectl exec -it <pod-name> -- <command>` | `kubectl exec -it my-pod -- sh` | Opens an **interactive terminal** (shell) inside a running container.       |
| `kubectl top <resource>`                   | `kubectl top nodes`             | Shows **CPU and Memory usage** for nodes or pods (requires Metrics Server). |

To get the usage like memory and cpu of all pods in an deployment. We should add the name of application as label app and then use label selector to aggregate the cpu usage.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-deployment
  # 1. METADATA LABELS: Labels for the Deployment object itself.
  labels:
    app: frontend
spec:
  replicas: 3
  selector:
    # 2. SELECTOR: Tells the Deployment which Pods to "own".
    matchLabels:
      app: frontend
  template:
    metadata:
      # 3. TEMPLATE LABELS: Labels that will be "stamped" onto every Pod created.
      labels:
        app: frontend
    spec:
      containers:
      - name: nginx
        image: nginx:latest
```

```sh
kubectl top pod -l app=frontend
```

Similalty we can get logs by label selector as well `-l` is there for selector. 

```sh
kubectl logs -l app=frontend --tail=20 -f
# Show pods that are part of the 'frontend' AND are in the 'production' environment
kubectl get pods -l app=frontend,env=prod
```

Note that label selector can be used rto gorup the stats and info about multiple of the resources. 

## Object management using yaml

Use `kubectl apply` to create all objects, except those that already exist, defined by configuration files in a specified directory:

```shell
kubectl apply -f <directory>
```

Add the `-R` flag to recursively process directories.
Run `kubectl diff` to print the object that will be created:

You can also use `kubectl apply` to update all objects defined in a directory, even if those objects already exist. This approach accomplishes the following:

1. Sets fields that appear in the configuration file in the live configuration.
2. Clears fields removed from the configuration file in the live configuration.

The diff should be applied so that we know what changes it will do in the cluster. 

```shell
kubectl diff -f <directory>
```

We can print the live configuration using get 

```shell
kubectl get deployment nginx-deployment -o yaml
```

We can also get the config as `json`. 

Manually deleting objects using the imperative command is the recommended approach, as it is more explicit about what is being deleted, and less likely to result in the user deleting something unintentionally:

```shell
kubectl delete -f <filename>
```

