---
title: "3. Shortest paths"
description: ""
date: "2026-02-05"
---



## BFS (for unweighted graph)

When every edge has the same cost (often assumed as cost 1), the shortest-path problem reduces to finding the minimum number of edges from a source vertex to all other vertices. Breadth-first search (BFS) is the canonical and optimal solution in this setting.BFS explores the graph in “layers” of increasing distance from the source: first all vertices at distance 0 (the source), then all at distance 1, then all at distance 2, and so on. This layered exploration is implemented with an ordinary queue: when a node is discovered for the first time, you set its distance to `distance[parent] + 1` and enqueue it. Because edges are unit-weight, the first time you visit a node you necessarily have found a shortest path to it.

```cpp
vector<int> bfs(int n,vector<vector<int>>& adj, int src){
    const int INF = 1e9;
    vector<int> dist(n, INF);
    queue<int> q;
    dist[src] = 0;
    q.push(src);
    while (!q.empty()) {
        int v = q.front(); q.pop();
        for (int u : adj[v]) {
            if (dist[u] == INF) { // dist inf is considered unvisited
                dist[u] = dist[v] + 1;
                q.push(u);
            }
        }
    }
    return dist;
}
```

## 0-1 bfs

Some graphs have only two distinct nonnegative edge weights: 0 and 1. A specialized variant of BFS called 0–1 BFS exploits this structure to compute shortest paths in O(V + E) time, similar to BFS. The trick is to use a deque (double-ended queue) instead of a queue. When we relax an edge of weight 0 we push the neighbor to the front of the deque, because visiting it does not increase the distance and should be processed immediately. For an edge of weight 1 we push the neighbor to the back. This behavior mimics Dijkstra’s algorithm with a binary priority queue but implemented more simply and faster in practice for these weights.

```cpp
vector<int> bfs(int n, const vector<vector<pair<int,int>>>& adj, int src) {
    // adj[v] contains (to, weight) with weight in {0,1}
    const int INF = 1e9;
    vector<int> dist(n, INF);
    deque<int> dq;
    dist[src] = 0;
    dq.push_front(src);
    while (!dq.empty()) {
        int v = dq.front(); dq.pop_front();
        for (auto [u, w] : adj[v]) {
            if (dist[v] + w < dist[u]){
                dist[u] = dist[v] + w;
                if (w == 0) dq.push_front(u);
                else dq.push_back(u);
            }
        }
    }
    return dist;
}
```


## Dijsktra algorithm

Dijkstra’s algorithm is the most widely used method for single-source shortest paths on graphs with nonnegative edge weights. The algorithm maintains a priority queue keyed by tentative distances from the source, repeatedly extracts the node with minimum tentative distance, and relaxes its outgoing edges. Because all weights are nonnegative, once a vertex is extracted from the priority queue its distance is final — no future relaxation can produce a smaller distance — which is the key invariant that guarantees correctness.

The canonical implementation uses a binary heap (C++ `priority_queue`), giving a runtime of O((V + E) log V) (or O(E log V) when E dominates). If the graph is dense and V is not too large, an adjacency matrix or a more direct O(V^2) implementation may be simpler and competitive.

A typical C++ Dijkstra stores the adjacency as `vector<vector<pair<int, long long>>> adj`, and uses a min-heap `priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<...>>` where the pair is `(distance, node)`.

On extracting a pair `(d, v)` you often check `if (d != dist[v]) continue;` to skip stale entries — entries that were pushed earlier with worse distances before a better distance was found. This lazy-deletion technique keeps code simple and efficient. 

```cpp
pair<vector<long long>, vector<int>> dijkstra(int n, const vector<vector<pair<int,long long>>>& adj, int src) {
    vector<long long> dist(n, INF);
    vector<int> parent(n, -1);
    dist[src] = 0;
    priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<>> pq;
    pq.push({0, src});

    while (!pq.empty()) {
        auto [d, v] = pq.top(); pq.pop();
        if (d != dist[v]) continue; // stale entry 
        for (auto [u, w] : adj[v]) {
            if (dist[v] + w < dist[u]) {
                dist[u] = dist[v] + w;
                parent[u] = v; // ensures that parent is smallest 
                pq.push({dist[u], u});
            }
        }
    }
    return {dist, parent};
}
```

### Maintaining Auxiliary Info: Counting Number of Shortest Paths and Multiple Shortest Paths

Sometimes you need more than distances: you might want the number of distinct shortest paths from the source to every vertex, or to keep track of the lexicographically smallest shortest path, or the earliest arrival times in time-dependent graphs. Counting shortest paths can be done within Dijkstra with a small augmentation: maintain a `count[v]` of how many shortest paths lead to `v`. Initialize `count[src] = 1`. When relaxing an edge `(v -> u)`:

- If `dist[v] + w < dist[u]`, set `dist[u] = dist[v] + w` and `count[u] = count[v]` (we found a strictly better path).
- Else if `dist[v] + w == dist[u]`, do `count[u] += count[v]` (we found additional shortest paths of the same length). Usually you take counts modulo some `MOD` if counts can be huge.

This approach relies on processing vertices in nondecreasing order of `dist[]`, which Dijkstra’s priority queue guarantees. If you want to also reconstruct all shortest paths, however, the number can grow exponentially; typically you build a DAG of shortest-path edges (`for edges v->u where dist[v] + w == dist[u]`) and then either DFS through that DAG or apply dynamic programming on topologically ordered nodes.

There are several important caveats when using Dijkstra in practice. First, Dijkstra **requires nonnegative edge weights**; if any negative-weight edge exists, the invariant “extracted vertex has final distance” breaks and the algorithm can give incorrect answers. Second, integer overflow is a practical concern when using `int` distances: prefer `long long` or explicitly check for overflow when edge weights or path sums may be large. Third, using an adjacency matrix and O(V^2) implementation is often preferable for dense graphs since the overhead of priority queues is larger there. Fourth, one must be mindful of stale entries in the priority queue; forgetting to skip outdated `(dist, v)` pairs can still be correct but slower; correct handling is to check `if (d != dist[v]) continue;`. Finally, when reconstructing paths, track parents carefully and document what tie-breaking you choose (first path found, lexicographically smallest, etc.) because the algorithm may produce any valid shortest path when multiple exist.




## Bellman–Ford: Handling Negative Edges and Detecting Negative Cycles

Bellman–Ford solves single-source shortest paths when edges may have negative weights, and it additionally detects negative-weight cycles reachable from the source. It relaxes all edges repeatedly: after `k` iterations, all shortest paths using up to `k` edges have been considered. In a graph with no negative cycles, a shortest path between two vertices uses at most `V-1` edges, so running `V-1` full relaxation passes guarantees correctness. To detect negative cycles, run one extra pass: if any distance can still be relaxed on the `V`-th pass, then a negative cycle exists and distances are undefined (they can be arbitrarily negative by looping the cycle).

Bellman–Ford runs in O(VE) time, which is slower than Dijkstra’s O(E log V) for sparse graphs. However, it is the standard choice when negative edges are present and you need to detect negative cycles. The algorithm is simple, robust, and easy to implement. It also forms the basis of some algorithms in economic modeling and routing where costs may become negative due to rebates or profits.

```cpp
pair<vector<long long>, bool> bellman_ford(int n, const vector<Edge>& edges, int src) {
    vector<long long> dist(n, INF);
    dist[src] = 0;
    for (int i = 0; i < n - 1; ++i) {
        bool any = false;
        for (auto &e : edges) {
            if (dist[e.u] != INF && dist[e.u] + e.w < dist[e.v]) {
                dist[e.v] = dist[e.u] + e.w;
                any = true;
            }
        }
        if (!any) break; // early exit
    }
    // Check for negative cycle reachable from src
    bool hasNegativeCycle = false;
    for (auto &e : edges) {
        if (dist[e.u] != INF && dist[e.u] + e.w < dist[e.v]) {
            hasNegativeCycle = true;
            break;
        }
    }
    return {dist, hasNegativeCycle};
}
```

## Floyd–Warshall: All-Pairs Shortest Paths via Dynamic Programming

When you need shortest distances between all pairs of vertices, the Floyd–Warshall algorithm is a simple, elegant dynamic programming method that computes the full `n × n` distance matrix in O(n³) time. The algorithm iteratively considers each vertex `k` as an intermediate vertex and updates `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`. Initially `dist[i][j]` is the direct edge weight between `i` and `j` if it exists, or `INF` otherwise. After processing all `k` from 1 to `n`, `dist[i][j]` becomes the shortest distance from `i` to `j` (or remains `INF` if unreachable). Floyd–Warshall automatically handles negative edge weights but cannot handle negative cycles: if a negative cycle exists, the diagonal `dist[i][i]` will become negative for vertices in or affected by that cycle.

Floyd–Warshall is particularly convenient because it is simple to implement and naturally provides not just distances but also a structure to reconstruct paths if you store a `next[i][j]` pointer (the first step on the shortest path from `i` to `j`). However, the cubic time cost makes it suitable mainly for graphs of up to a few hundred nodes in competitive programming or applications; for larger sparse graphs, running Dijkstra from each source (O(n E log V)) or Johnson’s algorithm (which uses reweighting plus n Dijkstra runs) is usually better.

```cpp
vector<vector<long long>> floyd_warshall(int n, vector<vector<long long>>& dist, vector<vector<int>>& next) {
    // dist[i][j] initialized to direct weights; next[i][j] = j if edge exists else -1
    for (int k = 0; k < n; ++k) {
        for (int i = 0; i < n; ++i) {
            if (dist[i][k] == INF) continue;
            for (int j = 0; j < n; ++j) {
                if (dist[k][j] == INF) continue;
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    next[i][j] = next[i][k];
                }
            }
        }
    }
    return dist;
}
```

## Advanced Considerations: Multiple Metrics, Path Constraints, and Counting

Real-world shortest-path problems often include twists: paths that must use at most `k` edges, second-shortest paths, constrained shortest paths (e.g., minimize cost while bounding time), or counting the number of shortest paths. Many of these can be solved by augmenting state in the graph (e.g., state = (node, edgesUsed) for edge-limited shortest paths), or by working on the shortest-path DAG to count or enumerate shortest solutions.

Counting shortest paths is straightforward inside Dijkstra and BFS as noted earlier. Enumerating or listing all distinct shortest paths may not be feasible if there are exponentially many; instead, build the DAG of shortest edges (edges `(v,u)` with `dist[v] + w == dist[u]`) and then either use DP over topological order or carefully enumerate limited numbers of paths.

Second-shortest path problems often require maintaining more than one best distance per node or using modified Dijkstra that tracks the two best distances found so far for each node. K-shortest path algorithms (Yen’s, Eppstein’s) are more specialized and typically involve heuristics or advanced data structures.

### Problem

You have an undirected weighted graph with n vertices and m edges, and also an array a with length n. You also have a list b of k (possibly non-distinct) vertices. For each bi, find the shortest path from bi to every other vertex with a twist: you can use the input edges normally, but you can also move from any vertex i to any other vertex j for a cost of ai+aj.

### Solution

Observe that problem is dijsktra but there at `O(V)^2` edges this makes the graph really difficult to handle. 
So we introduce the technique to add a virtual vertex which connects every node `i`. By the cost `a[i]`. Now suddendly the we have added only `O(n)` edges and one node. But we can direclty run dijsktra on this graph and get the answer.

```cpp

int n,m,k;
cin>>n>>m>>k;
vi a(n);
f(n)cin>>a[i];
vector<vector<pii>> adj(n+1);

f(m){
	int u,v,w;
	cin>>u>>v>>w;
	u--,v--;
	adj[u].pb({v,w});
	adj[v].pb({u,w});
}

f(n){
	adj[n].pb({i,a[i]});
	adj[i].pb({n,a[i]});
}

vi nodes(k);

f(k){
	cin>>nodes[i];
	nodes[i]--;
}

  

auto dijsk = [&](int src){
	const int INF = 1e18;
	vll dest(n+1,INF); 
	priority_queue<pll> pq;
	pq.push({0,src});
	dest[src]=0;
	
	while(!pq.empty()){
		auto [d,node] = pq.top();
		pq.pop();
		// cout<<d<<" "<<node<<endl;
		ll dist = -d;
		if(dist>dest[node])continue;
		for(auto child:adj[node]){	
		if(dest[child.F]>dest[node]+child.S){
			dest[child.F]=dest[node]+child.S;
			pq.push({-dest[child.F],child.F});
		}
	}
	return dest;
};

  

for(int node=0;node<k;node++){
	auto dest = dijsk(nodes[node]);
	for(int i=0;i<n;i++){
		cout<<dest[i]<<" ";
	}
	cout<<endl;
}
```

