# 7. Data Structure On Trees

---

We have various concepts of trees-

- DFS on tree
- Centroid - The node of tree such that if deleted divides the tree into component such that largest component is of size atmost `n/2`. A tree can only have one or two centers and centroid will always exist.
- Diameter and related concepts
- Edge contribution technique on tree
- Tree DP

Sometimes we need to deal with query on trees. Now most of times we need to think about rooted trees in this schenarios.

First data structure which is used is very often is Binary lifting data structure which stores for each node the `kth` ancestor.

## Binary lifting

TODO

### Maintaining aggregates

Many times we can maintain some aggregate in addition to the kth ancestor. These aggregates should be calculatable in atmost `log(n)` time. This technique can be used to solve the general problems where query is asked around some max/min value along certain path.

We can also maintain some data structure on the path from `node` to `root`. Simplest example of this will be depth of the node maintainance. This technique is also called ancestral property maintainance. To emply this technique a data sctructure will maintained while doing dfs

For instance to know the number of distinct colors on root to node we can maintain a multiset

```cpp
multiset<int> s;
int col[n];
int num_col[n];
void dfs(int node,int par){
    s.insert(node);
    num_col[node]=s.size();
    for(auto ch:adj[node]){
        if(ch==par)continue;
        dfs(ch,node);
    }
    s.erase(s.find(node));
}

```

Now this ancestral property is usefull sometimes directly in problems. Or it will employed in problems where something might cancel. For instance finding xor for each pair of nodes- If we maintain ancestral property `xor root to node`.
Now xor for a path is

```
xor on path a to b = xr[a]^xr[b]^lca(a,b)

```

This is because the xor till a ^ xor till b can have will be enough to find aggregate and all the duplicate values will already be cancelled out due to property of xor.

Note that in a tree there exist only one path between a pair of nodes. So a path in a tree is uniquely determined by the pair of nodes. A lca can almost in all schenarios used to solve the problem involving paths in trees. But binary lifting can not handle updates efficiently. So if updates are needed online then lca can not be used instead this means problem might be using segment trees or square root algorithm.
## Updates

When updates can be made on tree. Then it becomes necessary to use dynamic structures like segment trees or fenwick trees.
Now updates can be done majorly at two places-

- Update the value on the node
- Update the value on the edge - This can be handled by shifting the value to the next node. And now again you are dealing with updates on nodes.

Again update can be done in three manner

1. update the  single node.
2. Update all the nodes on path
3. Update all the nodes in a subtree

In queries there can be two things -

1. Path queries -
1. Aggregate finding - HLD(heavy light decompositon)
2. Count/check feasibility over some condition - Centroid decomposition
2. Subtree query
1. Count - Euler tour
2. Aggregates - Euler tour

Finally sometimes a graph can be converted into the tree based on some greedy property.

### Euler tour

The **Euler Tour Technique** is a way to **flatten a tree into an array** so that certain types of queries on the tree (like subtree sums, subtree minimums, etc.) can be answered using **range queries** on that array. It is also the smallest path which covers all the nodes.

Tree flattening can be done in two ways -

- Compressed
- Extended

Idea is to do simple dfs only but we are also interested in two kinds of times -

- Every time we **enter a node** (first visit), we note down its **entry time**.
- Every time we **exit a node** (after processing all its children), we note down its **exit time**.

So we can maintain two arrays - tin and tout. We also maintain a global counter t which keeps on incrementing.

Suppose tree is

```md
1
/ | \
2  3  4
/ \
5   6

```

Then dfs euler tour can be

```
1 → 2 → 1 → 3 → 5 → 3 → 6 → 3 → 1 → 4 → 1

```

This sequence records both entering and leaving nodes.
But sometimes, for subtree queries, we only care about **the first time** we visit a node — i.e., **entry times**.

intime - discovery time of node
outtime - largest node time in subtree.

For a every node we maintain both the values.

```cpp
int timer=0;
void dfs(int node,int par){
    // increase timer
    intime[node]=++timer;
    for(auto ch:adj[node]){
        if(ch==par)continue;
        dfs(ch,node);
    }
    // don't increase timer
    outtime[node]=timer;
}

```

Now consider for each node the `(intime,outime)` as the interval of node. Now from interval theory we know that
A set of intervals can be fully overlapping , non overlapping or partial overlapping.

In context of our intervals there intervals can never be partially overlapping. They will always be either fully overlapping or non overlapping.

Theorum 1: A node x will be in the subtree of node y iff the corresponding interal of node x lies fully inside the interval of node y.

In the extended version we update the timer two times per node. So each node will have distinct out time stamp. In ealier version the exit time of multiple nodes can be the same.

Compresed times is really usefull in subtree queries. But the extended version is really usefull in calculation of path queries.

```cpp
int timer=0;
void dfs(int node,int par){
    // increase timer
    intime[node]=++timer;
    for(auto ch:adj[node]){
        if(ch==par)continue;
        dfs(ch,node);
    }
    // increase timer
    outtime[node]=++timer;
}

```
