---
title: "4. Topological sorting"
description: ""
date: "2026-02-05"
---



Topological ordering (or **topological sorting**) is one of the most fundamental concepts in graph theory, especially for **Directed Acyclic Graphs (DAGs)**. It provides a linear ordering of vertices such that for every directed edge u→vu \rightarrow vu→v, vertex uuu appears before vvv in the ordering. In simpler terms, if one node depends on another, the dependent node must come later in the order.

## Methods to find topological ordering:

### Kahn's algorithm

This method relies on **in-degree calculation**, where the in-degree of a node is the number of incoming edges to it. Initially, all nodes with zero in-degree are added to a queue, meaning they have no dependencies. Then, repeatedly, a node is taken from the queue, added to the ordering, and all its neighbors’ in-degrees are decreased by one. Whenever a neighbor’s in-degree becomes zero, it is pushed into the queue. This continues until all nodes are processed. If, in the end, not all nodes are visited, the graph contains a cycle.

### dfs based methods

In this method, we perform a **Depth-First Search** on the graph. During the traversal, once all descendants (or outgoing edges) of a node are visited, that node is pushed into a stack (or added to a list in reverse order). The resulting stack, when reversed, gives the topological order. This approach naturally respects the dependency direction because nodes are only finalized after all their dependent vertices are processed.

Both methods have a time complexity of **O(V + E)**, where VVV is the number of vertices and EEE is the number of edges, making them efficient even for large graphs.

Cycle detection is a vital part of topological sorting because a valid topological order exists **if and only if the graph is acyclic**.  
In **Kahn’s Algorithm**, a cycle can be detected when, after processing all possible nodes, some vertices still have a non-zero in-degree — implying that they are part of a cyclic dependency.

In the **DFS-based approach**, a cycle is detected if we revisit a node that is already part of the current recursion stack. This can be done using a **three-state visitation system**:

- `0` → unvisited
- `1` → currently visiting (in recursion stack)
- `2` → fully processed

If we ever find an edge leading to a node marked as `1`, we have found a back edge, indicating a cycle.

```cpp
vi state(n,0);

function<bool(int)> rec = [&](int node){
	state[node]=1;
	for(auto ch:adj[node]){
		if(state[ch]==1){
			return false;
		}else if(state[ch]==0){
			if(rec(ch)==0)return false;
		}
	}
	state[node]=2;
	topo.pb(node);
	return true;
};
```

Detecting cycles is not just a side effect of topological sorting—it is often an essential requirement in problems that ask whether a valid ordering exists, such as checking if a set of tasks with dependencies can all be completed.

## Applications

1. Task scheduling : Given tasks and their dependencies, topological sort determines the order in which tasks must be executed.
2. **Course Prerequisites:** Problems asking whether all courses can be finished or to find the order to take them are direct applications of topological sorting.
3. **Longest Path in DAG:** Unlike general graphs where finding the longest path is NP-hard, in a DAG, the longest path can be efficiently found using topological order.

Moreover, in problems requiring **lexicographically smallest topological ordering**, a **min-heap** (priority queue) can replace the simple queue to ensure that the smallest node is always processed first.

It’s also important to note that topological ordering is **not unique** — multiple valid orderings can exist for the same DAG, depending on which node among the available zero in-degree nodes is processed first. Therefore, understanding when uniqueness matters and when it doesn’t is crucial in both theory and implementation.

**Topological Sort with Lexicographic Constraints:** Using a priority queue in Kahn’s algorithm ensures the smallest possible node is chosen each time, which is often required in programming challenges.

**Topological Sorting on Condensed SCC Graphs:** In graphs with cycles, we can first compute **Strongly Connected Components (SCCs)** using Kosaraju’s or Tarjan’s algorithm, compress them into a DAG, and then perform topological sorting on this condensed graph.