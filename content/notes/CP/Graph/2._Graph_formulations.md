---
title: "2. Graph formulations"
description: ""
date: "2026-02-05"
---



Many times a graph is not given directly or given in form such that its directly not usable under the given constraints. In such conditions we try to make the graph by certain formulations. Graph formulations involcve figuring two things out 
1. What is the nodes.
2. What is the edge. 

Once that is done we can use certain algorithms to solve the problem. In graph traversal problems for instance its known that some kind of traversal is required depending on the edge we can guess the correct algorithm. However it should be noted down that sometimes good enough thinking is required while quessing the start and end point for the problem itself. Sometimes we also add some proxy nodes to make code simpler. 

Furthermore there are multisource bfs variant which sometimes is useful for multisource traversal from start. 

Most of the edges are the unit items of the things one has to minimise. Eg a number of wall break. Number of tiles traversed. etc 

## Example 

Consider a 2d grid. It has certain start points `S`and some exits `E`. In between the start and end point there can be some blockers `#`.
You have to find out for each start point `S` what is the minimum count of walls one needs to break so that they can exit from any `Exit`.

`n<=1000 , m<=1000`
### Solution

Modelling as graph problem we will say that edge exists between any two neighbouring vertices. The edge weight is `1` if next vertex has a wall and `0` if it does not. This converts problem into `0-1` bfs. Now observe that if we will start from given source then we will have to find the min dist to every exit and then take the min out from there.  Why not multisource from starts?

**A multisource BFS from all start points `S`** would calculate `dist[r][c]` as the minimum walls to break to get from _any_ `S` to the cell `(r, c)`. 
If you then checked the `dist` value at all exit points `E`, `dist[E]` would tell you the minimum walls needed to connect _the-closest-S_ to _that-specific-E_. The problem asks for the reverse: for _each-specific-S_, find the minimum walls to reach _any-E_. Your proposed multisource BFS doesn't give you the answer for _each_ `S` individually.

The key insight is that the problem is **symmetric**. The minimum number of walls to break on a path from `S` to `E` is the _exact same_ as the minimum number of walls on a path from `E` to `S`.
Because of this, we can reverse the problem: **For each start point `S`, find the minimum cost to reach it from _any_ exit point `E`.**
This is a problem we _can_ solve with a single multisource BFS!

However if we start from all exits at once `multisource bfs` then we can very easily maintain the min dist to every point. So oberve we started from end instead of begin and did multisource `0-1` bfs. 

```cpp
 int n, m;
    cin >> n >> m;
    vector<string> grid(n);
    for (int i = 0; i < n; i++) cin >> grid[i];
    deque<pair<int, int>> dq;
    vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
    
    // Push all Exits as multi-source BFS start
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 'E') {
                dist[i][j] = 0;
                dq.push_back({i, j});
            }
        }
    }

    // 0-1 BFS
    while (!dq.empty()) {
        auto [x, y] = dq.front();
        dq.pop_front();

        for (int k = 0; k < 4; k++) {
            int nx = x + dx[k], ny = y + dy[k];
            if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;

            int cost = (grid[nx][ny] == '#') ? 1 : 0;
            if (dist[x][y] + cost < dist[nx][ny]) {
                dist[nx][ny] = dist[x][y] + cost;
                if (cost == 1)
                    dq.push_back({nx, ny});   // higher cost → push back
                else
                    dq.push_front({nx, ny});  // zero cost → push front
            }
        }
    }

    // Print answers for all start points 'S'
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 'S') {
                if (dist[i][j] == INT_MAX)
                    cout << "Start (" << i << "," << j << ") → Unreachable\n";
                else
                    cout << "Start (" << i << "," << j << ") → Min walls to break = " << dist[i][j] << "\n";
            }
        }
    }
```

## Shortest path general solving paradigm

In general there are four variations in shortest path paradigm depending upon source and destination

1. Single source and single destination - Normal bfs
2. Multiple source and multiple destination -
	In this paradigm there can be four variations as well
	1. Shortest path from any s to any e
	2. Shortest path from any s to every e
	3. Shortest path from every s to any e (if undirected graph 2-3 are symmetric)
	4. Shortest path from every s to every e (all pairs)

	Trick here is that when ever there is any on one side that side for example in above problem for every source we had to find the shortest path to any ending `e` . Now consider all the e to be connected to a given `E_final` with 0 cost. Now problem converts from any e to specific `E_final`. With that done we can simply do a bfs from `E_final` and calcualtion of dist to every `S`. Now by symmetric argument we can say that shortest dist from every s is caclcuated as `dist(E_final to S)`. 

Similarly if we want to find the min dist between any `S` to any `E` then we can connect the dummy `S1` to all S and connect a dummy `E1` to all `E` and that is it. 

For last one aka every pair we can not do it better than `O(min(S,E)*SSSP_ALGO)` 
Why not from everyside reason being we are running multisource bfs so it will calculate the shortest path from any `S` to every `E`. 

Now this dummy node push can be abstracted to pushing all the `Es` or `Ss` whatever in the queue at the begining.

3. Single source and multiple destination
4. multiple source and single destination

Now in above problem say we add one more constraints any path you are visiting must also be passing through a node P. So now for every `S` find the shortest exit given path goes through `P`.

One of the very good observation which can be used to solve problem of this kind is to break the path into two find the minimum path from `S-P` and then `P-E` and then solve. The problem is that in this question a cell may have been visited twice first during going to `P` and then after going from `P-E`.

However when we draw the path it will be like starting from `S` and it will reach some in between node `N` after this we will go to `P`. Then we will return back observe that two things can happen now  `P-E subpath` will have some common subset possibily empty with `P-N`. Whatever the common may be  we don't need to count it twice. 
Note that it can never happen that `P-E` will diverge first and then converge with `S-P` reason being that then it will be optimal to trace back the same S-P path as it will not have any blocker. 

So the optimal cost is `dist(S-X)+dist(X-P)+dist(X-E)` 
Now considering single `S` and single `P` then we can do bfs(S) , bfs(P),bfs(E) and then answer will be

```
ans = min(dist(s-i)+dist(p-i)+dist(e-i)) for all nodes i
```

Again solvable in `O(V+E)`. 

Observe that is just an extension of the airplane problem(cses) where we had to apply discount on any edge and so we divided the path into two ans was

```
ans = min(dist(s-u)+dist(v-e)) for all edges (u,v)
```

Now how to solve it for the `Every S to any E` version. This is not solvable in `O(V+E)`. However `any S to any P` is solvable just be the bfs `O(V+E)`

> [!NOTE] Note
> Sometimes we may try to find the solution based on steps. Aka first do the step 1 and then do other steps. For instance first do the greedy solution `S-P` and then do `P-E`. These kind of greedy solution will never work untill you have unique solution in the first place. 

Finally we may be required to have some information about the path. For instance printing the exact path or finding the number of paths. To do all of these we need to maintain the auxilary information about the path as we go. 

Some of the auxilary information include-

1. immediate parent
2. Number of paths etc

These auxilary informations are stored and updated as we reach any path. For bfs then for cacluation of number of paths we should directly do the number of paths.

## Multisource shortest path (MSSP)

Sometimes we are required to find the shortest path from every vertex to some subset to vertex say `D`. In this case we can not solve by starting a bfs from every source. Reason being it will be very slow. Idea in these problems is to use symmetry `dist(a,b) = dist(b,a)`. Note that since this is the case we can start a multisoruce bfs from set `D`. 

This is easy however problems may also introduce some constraints on the paths. More often we will be modeling some other problem as multisource shortest path. Constraints can be - 

From every vertex `v` find the two smallest distances to any distinct nodes d belong `D`. 

This can be solved by maintaining the source node as part of state stored in queue. However we also need to maintain the two shortest distance as part of distance state. 

```cpp

// Create the distance array
vector<vector<pair<int,int>>> best(N);

# pushing all the sources
queue<pair<int,int>> q; // (node, source)
for(int s=0;s<N;++s){
	if(S[s]=='S'){
		best[s].push_back({0, s});
		q.push({s, s});
	}
}

// bfs 
while(!q.empty()){
	auto node = q.front(); q.pop();
	int u = node.first;
	int src = node.second;
	int du = -1;
	for(auto &p : best[u]) if(p.second == src){ du = p.first; break; }
	if(du == -1) continue;
	for(int v : adj[u]){
		int nd = du + 1;
		bool changed = try_insert(v, nd, src);
		if(changed){
			q.push({v, src});
		}
	}
}
 
// one important thing is try_insert function 

// at very high level it just inserts one node and returns true or false depending upon if the distance can be made better. 

auto try_insert = [&](int v, int dist, int src)->bool{
	for(auto &p : best[v]){
		if(p.second == src){
			if(dist < p.first){
				p.first = dist;
				sort(best[v].begin(), best[v].end());
				return true;
			} else return false;
		}
	}

	if((int)best[v].size() < 2){
		best[v].push_back({dist, src});
		sort(best[v].begin(), best[v].end());
		return true;
	} else {
		if(dist < best[v][1].first){
			best[v][1] = {dist, src};
			if(best[v][0].second == best[v][1].second){
				if(best[v][0].first <= best[v][1].first){
					best[v].pop_back();
				} else {
					best[v].erase(best[v].begin());
				}
			} else {
				sort(best[v].begin(), best[v].end());
			}
			return true;
		} else return false;
	}
};
```

Observe that we need to push the node to queue if either of shortest two gets updated. Now you might be confused even if both of the shortest are gettting updated why are we putting the nodes in the queue. The reason is that the second best distance from src also be the best/second best distance from src. 

Now this gives us the important consideration in most problems it is important not only to maintain the state. Note that state in queue will usually mimic the dist array created. Certainly if queue is having two states for example `{src,xor}` then distance array needs to be same. 

Second important observation is when do you push the node in the queue. A node should be pushed into the queue only if there is a chance of other nodes benefitting to get the better path than this one. So this should be kept in mind. 
If we are too greedy then answer will be incorrect. If however we are pushing every update into the queue then time complexity will be too high.

Understand that any node will be realxed two times instead of one in `dijsktra`.
