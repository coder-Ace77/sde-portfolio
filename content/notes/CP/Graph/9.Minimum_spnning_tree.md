---
title: "9.Minimum spnning tree"
description: ""
date: "2026-02-05"
---



Spanning tree is the subtree of a graph `G` such that all the nodes are connected. Minimum spanning tree is that spanning tree which has minimum sum of edges of tree edges. 

### Properties of MST

- Cut property - For any cut of the graph , minimum wt edge crossing the cur must be part of the MST. This is logically true as chosing some other edge than this will lead to much larger mst. 
- Cycle Property - In any cycle the maximum weight edge of the cycle can not be part of MST. 
- **Minimax Property:** MST minimizes the **maximum edge weight** on the path between any two nodes. 
- **Exchange Property:** If you add a non-MST edge and remove the heaviest edge in the formed cycle, the total weight does not increase.

### Kruskal algorithm 

Sort all edges by weight and greedily add them if they donâ€™t form a cycle (checked using DSU).

```cpp
ll kruskal(int n, vector<array<int,3>>& e){
    sort(e.begin(), e.end(), [](auto &a, auto &b){ return a[2]<b[2]; });
    DSU d(n);
    ll ans=0;
    for(auto &x:e) if(d.unite(x[0],x[1])) ans+=x[2];
    return ans;
}
```

### Prins algorithm

Start from any node and keep adding the minimum edge that expands the tree using a priority queue. Best for **dense graphs** or adjacency lists.

```cpp
ll prim(int n, vector<vector<pair<int,int>>>& g){
    vector<int> vis(n);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    pq.push({0,0});
    ll ans=0;
    while(!pq.empty()){
        auto [w,u]=pq.top(); pq.pop();
        if(vis[u]) continue;
        vis[u]=1; ans+=w;
        for(auto [v,wt]:g[u]) if(!vis[v]) pq.push({wt,v});
    }
    return ans;
}
```

Note that for the MST on grids etc in manhatton - It is enough to have smallest edges so that we can fit into such tight constraints. Finally since MST is a tree we can do all sort of stuffs doable on MST.  