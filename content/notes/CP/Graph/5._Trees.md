---
title: "5. Trees"
description: ""
date: "2026-02-05"
---



## Basic definitions:

A tree is a connected, acyclic graph that consists of n nodes and n − 1 edges. Removing any edge from a tree divides it into two components, and adding any edge to a tree creates a cycle. Moreover, there is always a unique path between
any two nodes of a tree. 

*Leaves* are the nodes in trees with degree 1.In a rooted tree, one of the nodes is appointed the root of the tree. Note that concept of parent and child only matters for rooted trees. Each node has exactly one parent with root having none.
The structure of rooted trees is recursive and thus many recursive algorithms make sense.

## Properties of tree:

- A tree with `n` nodes has exactly `n-1` edges. And since we know that sum of `deg = 2*(n-1)` and each node has `deg(node)>=1` which means at max degree of a node can be `2*n-2 - n-1 <=n-1`. In a tree there can not be a node with deg n or greater.
- Another property is that it is a connected graph acyclic graph.
- In a tree any two pair of nodes have exaclty one path between them. So if we remove any edge it will become disconnected. 
- Adding an edge to a tree will create exactly one cycle. For further edges it depends upon upon the structure.

## General tree traversal:

```cpp
void dfs(int node,int par){
	// process 
	for(int child:adj[node]){
		if(child==par)continue;
		dfs(child,node);
	}
}
```

Since tree is recusive we can sometimes calculate the values either top-down meaning the quantity will be calculated for parent first and then child. Bottom up means to calculate the values of a node entire subtree must be calculated one example is the max node finding in each subtree. Here we need to calculate bottom up while in case where we need suppose need to find pairs where sum of nodes is some value `k` we can maintain datastructrue calculated top down.

Max value
```cpp
vector<int> ans(n,INT_MIN);
void dfs(int node,int par){
	if(child==par)continue;
	// max of current child is the max of all subtrees. but bottom value msut be calc first
	dfs(child,node);
	ans[node] = max(ans[node],ans[child]);
}
```

Also there is a certain paradigm where we can maintain the value for the entire path root to current node. Second problem of calculation of pair can be done by that.

```cpp
map<int,int> mp;
int ans=0;

void dfs(int node,int par){
	// we are maining in map freq of values root-child
	ans+=mp[k-val[node]];
	mp[val[node]]+=1;
	for(int child:adj[node]){
		if(child==par)continue;
		dfs(child,node);
	}
	mp[val[node]]-=1;
}
```


#### Finding path length: 

There are _n_ cities and _n_ - 1 roads in the Seven Kingdoms, each road connects two cities and we can reach any city from any other by the roads.

Theon and Yara Greyjoy are on a horse in the first city, they are starting traveling through the roads. But the weather is foggy, so they can’t see where the horse brings them. When the horse reaches a city (including the first one), it goes to one of the cities connected to the current city. But it is a strange horse, it only goes to cities in which they weren't before. In each such city, the horse goes with equal probabilities and it stops when there are no such cities.

Let the length of each road be 1. The journey starts in the city 1. What is the expected length (expected value of length) of their journey?

Basically we have to finding the expected path length from node to leaf over all the paths.

##### Solution:

First how do you find the expected path length.


	`Average = Sum of lengths of all paths/ total no of path` 

So if there are say 100 paths and the sum of length of all paths is say 5000 then avarge is 50. However there are still some issues. So one can go over all the paths which is number of leaves and then solve. 

There is one another technique left however -  

```cpp
function<void(int,int,double,int)> dfs = [&](int node,int par,double val,int len){
        int nc = (node==0?adj[node].size():adj[node].size()-1); // for root no of children is adj size while for others its one minus bacause one is parent in adj.
        bool ok=true;
        for(auto child:adj[node]){
            if(child==par)continue;
            ok=false;
            dfs(child,node,val/(double)nc,len+1);
        }
        if(ok){
            ans+=val*len;
        }
    };
```

Explanation: `val` actually tracks the probablity of path at certain node. Now prob on root node is 1. However moving forward any node having prob to end path there is `val`. For every child what is the prob its actually `val/no of its child` and so on. Finally if i say what is expectation By principle of counting 

`Expected length = Sum (Prob of path*length)` 

Variable `ok` is just there to find if the node is leaf or not.

there can be one more way to solve it - Bottom up suppose you know the expected values for the path starting at children and to leaf. So values are known for bottom subtrees how to find for child. 

It's actually will be `1+average over the children` Now this means we can solve the problem and the solution to a bigger problem is solved by dividing it into smaller sub problems and aggregating it for entire one. For this reason it looks like a tree dp but with no space each subproblem is solved just once and that is it.


## Diameter of a tree

A diameter of the tree `a→b` is the longest path, i.e., the one that maximizes `dist(a,b)` over all pairs of nodes. If there are multiple diameters, let's pick any of them.

It turns out the if we have a diameter it follows A very specific pattern

![Pasted image 20251023134353.png](/notes-images/Pasted%20image%2020251023134353.png)

Essentailly the end nodes of the diameter a really important. Another thing is that for any node `x` the node fartest to it has to be one of the end points of the diameter `a` or `b`. If that is not the case then we essentailly can get bigger diameter. 

This observation gives us very important observation. We can start with any node and find the node fartest to it `a`. The node fartest to it `a` will always be the one end point of diameter. If we again find a node fartest from `a` then we will get the second end point of diameter. 

Note that end points of diameter may not be unique and also if `a` and `b` are end points and `c` and `d` are end points then it is not necessary that `a` and `c` form a diameter. 

Algorithm

```cpp
auto [a,dist] = bfs(0); // returns the node fartest from 0 and dist to it
auto [b,dist2] = bfs(a); // return the actual length of diamter
```

this bfs implementation is quite simple and easy to follow

```cpp

/*
	Returns the end points and diameter length of the tree.
*/

tuple<int,int,int> tree_diameter(const vector<vector<int>>& g) {
    auto bfs = [&](int s) {
        int n = g.size();
        vector<int> dist(n, -1);
        queue<int> q;
        q.push(s);
        dist[s] = 0;
        int far = s;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int v : g[u]) if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.push(v);
                if (dist[v] > dist[far]) far = v;
            }
        }
        return pair{far, dist[far]};
    };

    auto [a, _] = bfs(0);
    auto [b, d] = bfs(a);
    return {a, b, d};
}
```

## Dynamic programming in trees:

Recursive structure of trees enable us to use dynamic programming style of solutions on trees. It should be remembered that dp can not be used on computation problem where there is an interdependency. However they are really usefull in case where it is either tree of its DAG(directed acyclic graph). At this point its worth mentioning that in general many dp problems are actually the traversal problems on trees.

Unlike traditional DP on arrays or grids, tree DP deals with recursive subproblems defined over **subtrees**  that is, each node’s answer depends on its children.

Tree DP is a powerful concept that combines graph traversal with optimal substructure properties. It’s widely used in **competitive programming**, **graph theory**, and **real-world hierarchical optimization problems**.

In a tree, every node can be seen as the root of a **subtree**. This observation naturally fits the **divide and conquer** principle — we can compute results for subtrees and combine them to form the result for the whole tree.

A typical recursive DP formulation on trees looks like:

```cpp
dp[u] = f(dp[v1], dp[v2], ..., dp[vk])
```

To compute these values efficiently, we perform a **Depth-First Search (DFS)** from the root, calculating `dp` values for children before their parent a **postorder traversal**.

### Example 1 size of subtree

We can define `subtree_size[u]` as the number of nodes in the subtree rooted at node `u`.

Recursive relation

```cpp
subtree_size[u] = 1 + sum(subtree_size[v] for all children v of u)
```

Code

```cpp

void dfs(int u, int p) {
    sz[u] = 1;
    for (int v : g[u]) {
        if (v == p) continue;
        dfs(v,u);
        sz[u] += sz[v];
    }
}
```

### General template

```cpp
void dfs(int node,int parent,<some state needed for calculation>,<some ds needed>){
	// perform some calculation which is needed by children
	for(auto child:adj[node]){
		if(child==parent)continue;
		dfs(child,node,..);
		// perform calculation or save
	}
	// end calculation which can be performed by looking at entire calculated subtree
}
```

### Finding diameter of the tree

The longest path _through_ it is the sum of the two largest child heights.

```cpp
int ans = 0;

int dfs(int u, int p) {
    int mx1 = 0, mx2 = 0;
    for (int v : g[u]) {
        if (v == p) continue;
        int h = dfs(v, u);
        if (h > mx1) mx2 = mx1, mx1 = h;
        else if (h > mx2) mx2 = h;
    }
    ans = max(ans, mx1 + mx2);
    return mx1 + 1;
}
```

### Max weight independent set on trees

Given a tree with weights on nodes, choose a subset of nodes such that:

- No two chosen nodes are adjacent.
- The sum of their weights is maximized.

`dp[u][0]` = maximum sum in subtree of `u` when `u` is _not included_.
`dp[u][1]` = maximum sum when `u` _is included_.

```cpp
void dfs(int u, int p) {
    dp[u][1] = w[u];
    for (int v : g[u]) {
        if (v == p) continue;
        dfs(v, u);
        dp[u][0] += max(dp[v][0], dp[v][1]);
        dp[u][1] += dp[v][0];
    }
}
```

Sometimes one may be required to use additional dp to solve for the subtree

### Rerooting technique

Rerooting (also called “DP on trees with root changes”) is a powerful technique that lets you compute a value for _every possible root_ of a tree in linear time. The core idea is: compute a DP that is easy when the tree is rooted at one fixed node (usually 1), then efficiently propagate information so you obtain the answer for every node as root without recomputing from scratch.

At a high level the pattern is:

1. choose an arbitrary root (say 1),
2. run a dfs to compute `down[u]` — answers that depend only on `u`’s subtree,
3. run a second dfs to compute `up[u]` — contribution coming from the rest of the tree not in `u`’s subtree (or directly compute the final answer for each node using parent's answer),
4. combine `down` and `up` to get the answer when rooted at each node.

#### Problem 

For every node `u`, compute `ans[u]` = sum of distances from `u` to all other nodes.

Derivation of reroot formula: suppose `v` is child of `u`. Let `sz[v]` be size of `v`’s subtree. If we know `ans[u]` (sum of distances from `u` to all nodes), then when we root at `v`, distances to nodes in `v`’s subtree decrease by 1 each (there are `sz[v]`), and distances to all other nodes increase by 1 each (there are `n - sz[v]`). So:

```
ans[v] = ans[u] - sz[v] + (n - sz[v]) = ans[u] + n - 2*sz[v]
```

Code

```cpp
vector<int> sz;
vector<long long> dp, ans;

void dfs1(int u,int p){
    sz[u]=1;
    dp[u]=0;
    for(int v:g[u]) if(v!=p){
        dfs1(v,u);
        sz[u]+=sz[v];
        dp[u]+=dp[v]+sz[v];
    }
}

void dfs2(int u,int p){
    ans[u]=dp[u];
    for(int v:g[u]) if(v!=p){
        long long du=dp[u], dv=dp[v];
        int su=sz[u], sv=sz[v];
        dp[u] -= dp[v] + sz[v];
        sz[u] -= sz[v];
        dp[v] += dp[u] + sz[u];
        sz[v] += sz[u];

        dfs2(v,u);

        dp[u]=du; dp[v]=dv; sz[u]=su; sz[v]=sv;
    }
}
```

# General key points, techniques, and pitfalls

1. **Choose a root & define states** — `down[u]`, `sz[u]`, `dp[u]`, etc. Clarity on what each DP means is essential.
2. **Two-pass structure** — first pass computes subtree-only values (`down`, `sz`, `dp`); second pass computes final answers using parent/other-subtree contributions.
3. **Prefix/suffix merges** — when combining many children and you need to exclude one child’s contribution efficiently, compute prefix and suffix aggregates over children so you can get “all except child i” in `O(1)` per child. This reduces naive `O(deg²)` merges to `O(deg)`.    
4. **In-place reroot vs closed formula** — if you can derive a direct formula to move answer from `u` to `v` (like `ans[v] = ans[u] + n - 2*sz[v]`), use it. Otherwise, use the in-place adjust-then-restore pattern shown in the tricky example.
5. **Memory & recursion** — recursion depth `n` may overflow stack for `n` up to 2e5; either increase stack or convert DFS to iterative. Also keep arrays sized `n+1`.
6. **Complexity targets** — correct rerooting solutions run in `O(n)` or `O(n * log n)` depending on extra data structures. Avoid `O(n*K)` merges inside `dfs2` unless K is small.
7. **Testing & sanity checks** — test on tiny trees (chain, star, balanced) and verify invariants (e.g., sum of subtree sizes equals `n`, sum of `ans[u]` symmetry checks).
8. **When to use rerooting** — per-node answers that depend on whole-tree structure (distance sums, subtree counts, max/min metrics when root changes, centroid-related computations, etc.) are ripe for rerooting.


Trees:(To learn)

1. Centre/centroid 
2. DFS / diameter
3. DS - Euler tour tree
4. Binary lifting
5. DP on trees
6. Maintianing some values using some data structure
7. DFS + DS (maintained for path to root) 
8. Queries on trees


Given a tree - Give answer for the following queries

- q(node) - Returns the fartest node from this node. 