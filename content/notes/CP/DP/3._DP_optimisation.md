# 3. Dp Optimisation

---

## DP state rotation

This is already being applied in knapsack 2 where weigths were very large idea is if some state can not be made small enough so that it can accomodate the large weights we can somehow switch some answer with the state. This is good if answer is small enough to be kept as a state

## State space reduction

In this problem a state can be figured out from the other states and this is not kept in the dp thus here we can simply remove this state. We have used this in the `cherry pickup` problem where we got the forth coordinate by calculation from other three.

Another problem : Divide the n numbers into two subsets such that `sum(set1)%sum(set2)==0` All the numbers have to be taken into consideration. Normally we will keep both sum in state but sum2 can fugired out from sum1 alone. So that is optimisation.

## Greedy optimisation

Now sometimes a dp problem can be solved in conjuection with applying the greedy technique.  Here moslty some sorting idea will be best to employ. For example -

### Problem

Given n persons each person has two scores. `A(i) and B(i)` now if the person goes into the team 1 then total score increases by `A(i)` and if goes to team B total score increases by `B(i)`. What  is the maximum attainable score such that team A has exactly `a` person in the end and team B has `b` in the end.

constraints:
`n,a,b<=1000`
### Solution

Observe that problem is pretty easy to solve with complexity `O(n*a*b)` because we can keep the number of A selected so far and number of B selected so far into the state. Now if a+b=N then we could have used state space reduction.

Observe that if we know which B's have been selected then we have greedy choice while selecting A. Bascially max value A's must be selected after removing the B's. But we can do this after all B's are selected as there is no way to maintain that. So what should we do?

We have to select elements of A while selecting B

Suppose if we sort all the elements in the reverse order of A. and then omit the state of B.

Now an element can be selected in team B or not selected in team B if not selected we have greedy strategy to select this in A reason being all the other values are suboptimal than this choice. So solution follows

1. Sort on the basis of A
2. `dp(i,b) = Max score attainable such that we have selected b elements in first (0,i)`
3. `dp(i,b) = max(dp(i-1,b)+(i-b>=0 && i-b<=a)?a[i]:0,dp(i-1,b-1)+b[i])` // reason if we are not taking in b then take in a as it is optimal.

```cpp
int rec(int i,int b){
    if(i<0)return 0;
    if(dp[i][b]!=-1)return dp[i][b];

    int ans = 0;
    if(b>0){
        ans=max(ans,rec(i-1,b-1)+b[i]);
    }
    int cnt_a=i+1-b;
    if(cnt_a>=0 && cnt_a<=a){
        ans = max(ans,rec(i-1,b)+a[i]);
    }
    return dp[i][b] = ans;
}

```

### Transition optimisation

Optimisation of transitions is usually much easier than manipulation of state aka removing or roatating state. Now transistions can be optimised using some datastructure or by some property as well. Or in some cases by optimisation of prefix sums.

### Space optimization

Usually when the value of row calculation depends entirely on the previous row then this can be applied. Sometimes it is also applicable in1d dp if the value of ith level depends on some prev level. In that case the dp will be reduced to constant space for example frog jump or ladder or fabonacci number solution.

For row wise optimisation we have to get the answer of current row by looking into the previous row. This we have talked back in knapsack problem. Now its important to note down that there are essentially two paradigm of row space optimisation.

1. prev,curr dp prardigm
2. modulo paradigm

## Data structure optimisation
### Problem

A person in city 1 wants to reach city N. To reach there there are two ways either he can go to next city using bus using `B[i]` cost. we can fly to any of then next k cities by giving cost `A[i]+A[j] j<=i-k`

#### Solution:

It is really easy to solve problem using `O(n*k)` because say we are at city i then either we would have came from i-1 using bus or from any of city `[i-1,i-k]`  using flight. So transition will cost `O(k)` per state.

```cpp
int rec(int i){
    if(i<0)return inf;
    if(i==0)return 0;
    if(dp[i]!=-1)return dp[i];
    int ans = rec(i-1)+b[i-1];
    for(int j=1;j<=k;j++){
        ans = min(ans,rec(i-j)+a[i-j]+a[j]);
    }
    return dp[i]=ans;
}

```

Iterative

```cpp
dp[0]=0;
for(int i=1;i<n;i++){
    dp[i] = dp[i-1]+b[i-1];
    for(int j=1;j<=k && i-j>=0;j++){
        dp[i] = min(dp[i],dp[i-j]+a[i-j]+a[i]);
    }
}
cout<<dp[n-1];

```

Optimisation:

Once writing the dp code lets try to optimise the transitions. Observe that but transition is `O(1)` however other transition is not O(1) however if we look into it we are minimising this

```
ans = min(dp[i-j]+a[i-j])+a[i] // a[i] can be taken outside as common

or

ans = min(dp[j]+a[j])+a[i] where j>=i-k

```

so this `dp[i-j]+a[i-j]` can actually be stored in a datastructure like segment tree and updated one by one. So this becomes range query in the range `[i-k,i-1]` and thus it becomes `O(nlogn)`.

```cpp
dp[0]=0;
for(int i=1;i<n;i++){
    dp[i] = dp[i-1]+b[i-1];
    //for(int j=1;j<=k && i-j>=0;j++){
        //dp[i] = min(dp[i],dp[i-j]+a[i-j]+a[i]);
        //}
    int indx = max(0,i-k);
    dp[i] = min(seg.qry(0,i-1)+a[i],dp[i]);
    sqg.upd(i,dp[i]+a[i]);
}
cout<<dp[n-1];

```

> [!NOTE] Maintaining agegrate in a window
> Note that transition optimisation translated to the maintainance of minimum value in the fixed window of size k. Now depending upon the aggregate there are many possibilities. Segment trees can handle almost all types of aggregates.  Min/max can also be handled by multiset as they maintain order. But all of them introduce a `log` factor. With monotone deque however we can get constant time complexity.

Now lets add one more constraints we can take only `M` flights. So it will increase one state

```cpp
// dp[j][i] = min cost to reach ith city using j flights
for(int j=0;j<=m;j++){
    for(int i=1;i<=n;i++){
        if(i==1 && j==0)dp[j][i]=0;
        else if(i==1)dp[j][i]=inf;
        else{
            dp[j][i] = dp[j][i-1]+b[i-1];
            if(j>0){
                dq.insert(dp[j-1][i-1]+a[i-1]);
                if(i-k>=0)dq.remove(dp[i-k]+a[i-k]);
                dp[j][i] = min(ans,dq.getmin()+a[i]);
            }
        }
    }
}

```

### Space optimisation

Now we observe that current state dependent on prev `j` or current `j` only.  We can very well maintain prev and dp tow arrays but instead we can use `row&1` trick to toggle between even and odd states.

```cpp
const long long INF = 1e18;
vector<vector<long long>> dp(2, vector<long long>(n+1, INF));

for (int j = 0; j <= m; j++) {
    deque<long long> dq;
    for (int i = 1; i <= n; i++) {
        if (i == 1 && j == 0) dp[j & 1][i] = 0;
        else if (i == 1) dp[j & 1][i] = INF;
        else {
            long long val = dp[j & 1][i-1] + b[i-1];
            if (j > 0) {
                // Insert candidate for taking flight
                dq.remove();
                dq.insert(dp[(j-1) & 1][i-1] + a[i-1]);
                val = min(val, dq.getmin() + a[i]);
            }
            dp[j & 1][i] = val;
        }
    }
}

```

Final answer will be in the state `dp[m&1][n]`.
