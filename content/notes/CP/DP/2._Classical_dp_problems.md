# 2. Classical Dp Problems

### House Robber:

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**.

##### Solution:

This can be solved either using form 1 or form 2.
Form 1 is easier though

`dp(i) = max loot in first i homes`

Recurrence

`dp(i) = max(dp(i-1),dp(i-2)+a[i])`

code:

```java
int rec(int n){
    if(n<0)return 0;
    if(dp[n]!=-1)return dp[n];
    return dp[n]=Math.max(rec(n-1),rec(n-2)+arr[n]);
}

```

### Longest increasing subsequence:

we have $O(n^2)$ solution of LIS

```cpp
int rec(int i){
    if(i<0) return 0;
    int ans = 1;
    for(int j=0;j<i;j--){
        if(a[j]<a[i])ans = max(ans,dp[j]+1);
    }
    return ans;
}

```

Now we can also solve LIS using binary search.

We maintain an array `tail[]` where:

- `tail[len]` = **smallest possible tail element** of an increasing subsequence of length `len + 1`.
We iterate through each number and use **binary search** to find where it fits in `tail`.

```cpp
int lengthOfLIS(vector<int>& a) {
    vector<int> tail;
    for (int x : a) {
        auto it = lower_bound(tail.begin(), tail.end(), x);
        if (it == tail.end())
        tail.push_back(x);
        else
        *it = x;
    }
    return tail.size();
}

```

Each `tail[i]` is **the smallest possible ending value** of an increasing subsequence of length `i + 1`.

By always keeping tails minimal:

- we maximize chances to extend subsequences later,
- and ensure that binary search helps find where to replace or extend efficiently.

This is `O(nlogn)` solution.

Finding the lis : To get  the lis subsequence we have to track the element indexes as well

- `tail_idx[i]` — index in `a` of the **last element** of the smallest subsequence of length `i + 1`
- `prev_idx[i]` — index of the **previous element** in LIS ending at index `i`
- `len` — current LIS length (size of `tail`)

```cpp
vector<int> getLIS(vector<int>& a) {
    int n = a.size();
    vector<int> tail_idx;      // stores indices of tail elements
    vector<int> prev_idx(n, -1); // link to previous element in LIS

    for (int i = 0; i < n; i++) {
        int x = a[i];
        auto it = lower_bound(tail_idx.begin(), tail_idx.end(), x,
        [&](int idx, int val) { return a[idx] < val; });
        int pos = it - tail_idx.begin();

        if (it == tail_idx.end()) tail_idx.push_back(i);
        else tail_idx[pos] = i;

        if (pos > 0)
        prev_idx[i] = tail_idx[pos - 1];
    }

    // reconstruct LIS
    vector<int> lis;
    for (int i = tail_idx.back(); i != -1; i = prev_idx[i])
    lis.push_back(a[i]);
    reverse(lis.begin(), lis.end());
    return lis;
}

```

## 0-1 knapsack problem:

We are given  `n` items, each with a `value[i]` and a  `weight[i]`. A  **knapsack** that can carry at most `W` weight.
You must **maximize total value** of selected items such that `**total weight ≤ W**`.

### Solution:

Now greedy solution will not exist reason being the set of choices for weigth w can be totally different from the set of choices made to have weight w-1.

So the recurrance is -

Assuming that all states of the first  `i-1`  items have been processed, what are the options for the  `ith`  item?

- When it is not put into the knapsack, the remaining capacity remains unchanged and total value does not change. Therefore, the maximum value in this case is  `f_{i-1, j}`
- When it is put into the knapsack, the remaining capacity decreases by  `w_{i}`  and the total value increases by  `v_{i}` , so the maximum value in this case is  `f_{i-1, j-w_i} + v_i`

`f_{i, j} = \max(f_{i-1, j}, f_{i-1, j-w_i} + v_i)`

Now since `f(i)` depends only on `f(i-1)` thus first dimention can be removed.

`f_j \gets \max(f_j, f_{j-w_i}+v_i)`

So the code

```cpp
for (int i = 1; i <= n; i++)
for (int j = W; j >= w[i]; j--)
f[j] = max(f[j], f[j - w[i]] + v[i]);

```

Again, note the order of execution. It should be strictly followed to ensure the following invariant: Right before the pair  `(i, j)`  is processed,  $f_k$  corresponds to  `f_{i,k}`  for  `k > j` , but to  `f_{i-1,k}`  for  `k < j` . This ensures that  `f_{j-w_i}`  is taken from the  `(i-1)` -th step, rather than from the  `i` -th one.

More clear code:

Here with optimized space

```cpp
vll dp(w+1,0),prev(w+1,0);
for(int i=1;i<=n;i++){
    for(int weight=0;weight<=w;weight++){
        dp[weight] = max(prev[weight],dp[weight]);
        if(wt[i]<=weight)dp[weight] = max(dp[weight],prev[weight-wt[i]]+v[i]);
    }
    prev=dp;
}

```

There is one more pattern where weigth can be large here we try to find the min weight achieval for given value constraints and that's it.

```cpp
dp[0]=0;
prv[0]=0;
int ans = 0;
for(int i=1;i<=n;i++){
    for(int val=0;val<=max_value;val++){
        dp[val] = min(prv[val],dp[val]);
        if(val>=v[i])dp[val] = min(dp[val],prv[val-v[i]]+wt[i]);
        if(dp[val]<=w)ans = max(ans,val);
    }
    for(int val=0;val<=max_value;val++)prv[val]=dp[val];
}

```

Usually in the case where we need to pick some elements (sequence of choices) and bottom up solution is needed we should start with index 1 and should iterate on legth instead of index. It always leads to cleaner and more elegant solutions.

Note that there is a way to eleminate the prev vector as well.

Subset sum : In this problem we have to make some target sum by selecting some subset of elements from an array.

At each point we keep the sum and current number of elements traversed and move forward.

```cpp
bool subsetSum(vector<int>& a, int i, int sum) {
    if (sum == 0) return true;
    if (i == 0) return a[0] == sum;
    bool notTake = subsetSum(a, i-1, sum);
    bool take = false;
    if (a[i] <= sum)
    take = subsetSum(a, i-1, sum - a[i]);
    return take || notTake;
}

```

Sometimes some small tricks can convert some different looking problem into dp problem consider this question https://leetcode.com/problems/target-sum/description/. Now instead of solving the question in its entirety which can be done using dp again. We can change the problem little bit. Since each number in nums is positive we can add `x = sum(nums)+target`. Now x should be divisible by 2 and we must find the subset sum of size sum/2.

## Subset sum bitset optimisation:

Recall that we can write the bottom up for subset sum as

```cpp
bool subsetSum(vector<int>& a, int S) {
    int n = a.size();
    vector<vector<bool>> dp(n + 1, vector<bool>(S + 1, false));

    for (int i = 0; i <= n; i++) dp[i][0] = true;

    for (int i = 1; i <= n; i++) {
        for (int s = 1; s <= S; s++) {
            bool notTake = dp[i - 1][s];
            bool take = false;
            if (a[i - 1] <= s)
            take = dp[i - 1][s - a[i - 1]];
            dp[i][s] = take || notTake;
        }
    }
    return dp[n][S];
}

```

Now we can optimise it for it we can use one more vector to have the previsous row but carefully looking at the state calculation of inner elements observe that while calculating the values for i+1 th state say for sum =j then it will always require the sum of prev row which is less than sum. In the other words `dp[j]` will always access the prev row for sum at most j this means if we update the state in the reverse order we will always get correct result as values before it are valid for last row only. Now one thing we don't need to wory about moving the not_taken as there is just one array storing answer so it automatically has the values.

Observe that having the one array also removes one pass.

```cpp
bool subsetSum1D(const vector<int>& a, int S) {
    int n = a.size();
    vector<char> dp(S+1, 0);
    dp[0] = 1;
    for (int i = 0; i < n; ++i) {
        int x = a[i];
        for (int s = S; s >= x; --s)
        if (dp[s-x]) dp[s] = 1;
    }
    return dp[S];
}

```

Now the operation inside loop is just updating some values after it so we can replace it with bit operations. `dp = dp | (dp << x)`

```cpp
bool subsetSumBitset(const vector<int>& a, int S) {
    const int MAXS = 10001; // must be >= S+1
    bitset<MAXS> dp;
    dp[0] = 1;
    for (int x : a) dp |= (dp << x);
    return dp[S];
}

```

## Coin change:

There are many variants of this problem. Lets discuss one by one:

### Problem 1

Consider a money system consisting of nnn coins. Each coin has a positive integer value. Your task is to produce a sum of money xxx using the available coins in such a way that the number of coins is minimal.

Solution:

A naive way to solve it will be to go over each coin and maintaining the sum and also going over the multiple of coins.
```cpp
for(int sum=0;sum<=target;sum++){
    for(int coin=0;coin<=n;coin++){
        for(int taken=0;taken*val[coin]<=sum;taken+=1){   // o(n^3)

        }
    }
}

```

But we can be clever here : Lets take only sum in the state and we will try to take coins one by one

```cpp
int rec(int sum,vi &coins){
    // base cases
    if(sum==0)return 0;
    if(sum<0)return 1e9;
    if(dp[sum]!=-1)return dp[sum];
    int ans = 1e9;
    for(auto c:coins){
        ans = min(ans,1+rec(sum-c,coins));
    }
    return dp[sum]=ans;
}

```

### Problem 2

Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ways you can produce a money sum x using the available coins.

```cpp
vi dp(x + 1, 0);
dp[0] = 1;
for (int i = 1; i <= x; i++){
    for (int j = 0; j < n; j++){
        if (i - v[j] >= 0){
            dp[i] += dp[i - v[j]];
            dp[i] %= 1000000007;
        }
    }
}
cout << dp[x];

```

Observe that here we are calculating for a given sum `x`  how many ways are there in `(0,j)`. Now in this problem order matters means same set of coins if order changes will be counted differently.

There is one more variation where changing order does not matters. So lets see that

### Problem 3

Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to calculate the number of distinct _ordered_ ways you can produce a money sum x using the available coins.

Now we will just swap the top loops and ans will be there. The reason being we are always iterating on the coins in order so only one order of coins will be formed. Not multiple times. Also

```cpp
vi dp(x + 1, 0);
dp[0] = 1;
for (int j = 0; j < n; j++){
    for (int i = 1; i <= x; i++){
        if (i - v[j] >= 0){
            dp[i] += dp[i - v[j]];
            dp[i] %= 1000000007;
        }
    }
}
cout << dp[x];

```

## Edit distance:

The _edit distance_ between two strings is the minimum number of operations required to transform one string into the other.

The allowed operations are:

- Add one character to the string.
- Remove one character from the string.
- Replace one character in the string.

### Solution:

`dp(i,j) = minimum operations required to match the string s(0,i) and t(0,j)`
Now there are four possibilities.Now about `s[i]` and `t[j]` if both same then no need of operations and we can try matching `s[0..i-1] and t[0...j-1]` otherwise we can have either replacing or removing opertions

```cpp
for (int i = 0; i <= na; i++){
    for (int j = 0; j <= nb; j++){
        if (i){
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);
        }
        if (j){
            dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);
        }
        if (i && j){
            dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + (a[i - 1] != b[j - 1]));
        }
    }
}

```

And that is it.

## LCS using LIS in O(nlogn):

We can very easily compute the longest common subsequence using LIS if the values in both the arrays are unique.
Idea is first to map the values to the indexes and then in any array A replace the values by the value of index. Now observe that increasing indexes in A means these indexes are also present in B and precisely in the same order. Thus it forms longest common subsequence.

```cpp
int LCS_using_LIS(vector<int>& A, vector<int>& B) {
    unordered_map<int,int> mp;
    for (int i = 0; i < B.size(); i++) mp[B[i]] = i;

    vector<int> transformed;
    for (int x : A) if (mp.count(x)) transformed.push_back(mp[x]);

    return lis(transformed); // lis using nlogn
}

```

## Cherry pickup:

Here we have to find out the maximum number of cherries we can get in a round trip in a 2d grid. During down trip we can move right-down and during up trip we can move left-up.

### Solution:

The big idea here is that while going up we may have encountered the same cell twice and thus may pick cherry twice. To solve this one idea is to move two persons at the same time from top. Now if both persons can come at the same spot they will also be there at the same time. So it is enough to keep four things in state `(x1,y1) and (x2,y2)`. Also `x1+y1==x2+y2 = time elapsed` so we can omit one state. and get the `O(n3)` solution.

```
dp[r1][c1][r2] = maximum cherries collected
when player1 is at (r1, c1)
and player2 is at (r2, c2)

```

```cpp
int dfs(vector<vector<int>>& g, int r1, int c1, int r2) {
    int c2 = r1 + c1 - r2;
    if (r1 >= n || c1 >= n || r2 >= n || c2 >= n ||
    g[r1][c1] == -1 || g[r2][c2] == -1)
    return -1e9;

    if (r1 == n - 1 && c1 == n - 1)
    return g[r1][c1];

    int& res = dp[r1][c1][r2];
    if (res != -1) return res;

    int cherries = g[r1][c1];
    if (r1 != r2) cherries += g[r2][c2];

    int best = max({
        dfs(g, r1 + 1, c1, r2 + 1),
        dfs(g, r1, c1 + 1, r2),
        dfs(g, r1 + 1, c1, r2),
        dfs(g, r1, c1 + 1, r2 + 1)
    });

    res = cherries + best;
    return res;
}

```
