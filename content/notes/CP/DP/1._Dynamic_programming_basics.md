---
title: "1. Dynamic programming basics"
description: ""
date: "2026-02-05"
---



1. Dynamic programming can be think as the recursive(backtracking) mindset. 
2. Recognise the form of dp is crutial in solving dp problems. -> pattern
3. formulate the problem as dp(state) = (meaning) -> thing computed by dp. This is 90% of time the value asked.
4. Most of dp are of this forms:
	1. Object iteration
	2. Ending dp
	3. Multiarray dp 
	4. lr dp 
	5. Game dp
5. There are other forms as well - 
	1. Digit dp 
	2. tree dp
	3. bitmask dp
6. Modelling the transitions. (imp)
7. Save and return.
8. Any dp problem can be categorised into three categories.
	1. Classical 
	2. Non classical -> twisted version of classical
	3. competitive


> [!NOTE] Tips about writing recursion correctly
> First write the state and what will it compute. Then find the minimal state-> minimal state is the minimum information required to solve the problem. We consider and assume that for given state consider that its smaller form is already implemented. Then how are you going to find the correct value for given state from smaaler states. That is it for writing recursion.
> Concept of level , choice , check and move. Level is going to be current config then what are my choices. Check is given the choices which are valid and which are invalid. Move is the transition. 
> 

Solving N queens:

1. In any row only one queen can be placed.
2. We can keep in bitmask which cols are used. 
3. Now our dp is -> dp(row,bitmask) = no of ways given we are placing last queen at row such that bitmask is keeping track of which cols are already used. 


> [!NOTE] DP vs Greedy
> One thing which I have observed many times is that in dp problems most of the times there is something to optimise which is also the case with greedy. But with dp there is some other restriction too. This is usually what makes dp diff from greedy. Finally most of the optimisation problems where a person may confuse itself lie in knapsack category. The thing is that knapsack problems have inherent acceptance about the situation  that for a given current chioce for this level it may not be the perfect choice given we are calculating some other level. For eg -> the smallest cost to incur for making some x sum may have differnt set of choices than for the sum y and so on. So mostly all possible schenaios have to be seen. There can be optimisations lying underlying which might be greedy.

```cpp
int solve(state){
	base cases;
	memoise;
	for(all choices){
		if(valid(choice)){
			move(choice);
		}
	}
	return ans;
}
```


Note: Memory limit for functions is 10^6 and for global arrays it is 10^7

States are actually collapsable into some more information dense form. For example set of choices if limited can be stored as bitmask. 

### Framework:

1. Look for form of problem.
2. Decide the meaning and state.
3. Find the transition function.



> [!NOTE] Time complexity
> TC= #S(1+average #c of transition per state)

### Type 1 DP: 

In these type of problems there is a concept of choices you are at given point then you have to take some choice and move forward. These are also kind of simluations problem. We may have to add to state the extra info needed to calc the correct answer.

Like -> Frog jump , grid paths etc..

#### Subset sum:

Find if there is a subset which sums upto x. 
`n<=100` , `x<=10000`

Solution: Classical we wil move on items(levels) one by one choices there are is either ot choose or not to choose. Move to next. And this goes on. 
```cpp
dp(i,x) -> Find if first i elements can form sum upto x or not. 
dp(i,x) = dp(i-1,x) || dp(i-1,x-arr[i]) // can we form sum wither by taking or not taking. 
```

code: 
```cpp
int rec(int i,int x){
	if(i<0)return x==0;
	bool ok = rec(i-1,x);
	if(arr[i]<=x) ok = ok || rec(i-1,x-arr[i]);
	return ok;
}
```

printing solution:

Idea is to use the earlier written recursion and use that to solve the problem. 
Basically we would be able to figure out the choices made at given step by comparing the values.
suppose first choice gives yes then we can put that into ans. Now second choice need not to be explored.
Similarly if first choice fails we can check if second is the valid choice and move in that direction.

In this tech we create a dfs function:

This would function dfs must have same state.
Now we have base cases but instead of returning a value we stop.

Then we move to choices and move further.

```cpp
vector<int> ans;
void dfs(int i,int x){
	if(i<0)return;
	if(rec(i-1,x)==1)dfs(i-1,x);
	else if(rec(i-1,x-arr[i])==1){
		ans.push_back(i); // storing that this choice was taken
		dfs(i-1,x-arr[i]);
	}
}
```

LIS(Longest increasing subsequence ) can be solved using form 1 as follows - Observe that is also a choice based problem. Now to solve this when goining over a choice we can simply also keep the last taken element's index. Now for current state `i` and for previous taken  `j`  we can either take it or not take it. So 

```
dp[i,j] = max(dp[i-1,j],dp[i-1,j]+1 given a[i]>a[j])
```

Code: forward dp - easier to visualiza and write

```cpp
void rec(int i,int j){
	if(i>n)return 0;
	ans = rec(i+1,j);
	if(j==-1 || a[i]>a[j])ans = max(ans,rec(i+1,i)+1);
	return ans;
}
```

### Form 2 Ending form:

In form two we can have many states but very first state says dp(i,...) = ans of seq or whatever it is such that it is ending at index i. So in lis the choice for i is not there and its compulsory.

Lets solve LIS using form 2

dp(i) = best length of lis ending at i with strictly keeping i as last element. 
	= max(dp(j)+1) for all `j<i` && `a[j]<a[i]`

So now space is reduced.

Code: Lets form backward dp
```cpp
int rec(int i){
	if(i<0) return 0;
	int ans = 1;
	for(int j=0;j<i;j--){
		if(a[j]<a[i])ans = max(ans,dp[j]+1);
	}
	return ans;
}
```

This approach has better space complexity. `O(n)`

 Similarly the question to have max / in sum path in a 2d matrix with only down + right moves is solvable using form2 
 TC : `O(n*m)`

Note: In some problems we keep visited/done to save the fact weather we have reached some state or not.

### Form 3 Multisequence / Multiarray dp:

In this type of problems ususally there are two or more arrays. Problem generally asked questions related tonchoices in both the arrays while having some condition. Here our state first contains the pointer to the indexes of the arrays and then any thing needed to compute state comes. 

```
dp(i,j,...) = ans formed by choosing in fisrst a[0,i] and b[0,j]
```

Q: LCS - longest comon subsequence can be formulated using this technique. 

The Longest Common Subsequence (LCS) problem involves finding the longest sequence of characters that appears in the same relative order (though not necessarily contiguously) in two or more given sequences

Now solution:

```
dp(i,j) = lcs of a(0,i) and b(0,j) 
```

Now for transition if `a[i]==b[j]` then ans is to match i and j then find ans in i-1,j-1. However if not match then either we have to not choose i or not choose j or not choose both(redundant)(why?)

```
dp(i,j) = 1+dp(i-1,j-1) if a[i]==b[j]
		= max(dp(i-1,j),dp(i,j-1)) 
```


```cpp
int rec(int i,int j){
	if(i<0 || j<0)return 0;
	ans = rec(i-1,j);
	ans = max(ans,rec(i,j-1));
	if(a[i]==b[j])ans = max(ans,rec(i-1,j-1));
	return ans;
}
```

LCS in three subsequence: 

Again we have to keep three pointers as state now. The solution will be `O(n)` one may ask why can not we find lcs of first two arrays and then lcs with that meaning `lcs(a,b,c) = lcs(lcs(a,b),c)`  well that is not true reason being there can be multiple lcs of a given pair of strings and that could have been suboptimal.

## Interval dp:

**Interval DP** (Dynamic Programming on intervals) is a **technique used when the problem involves choosing optimal operations or partitions on subarrays / substrings / intervals** of an array or string.

It’s most commonly used when:

- You must **combine results of smaller intervals** to form results for larger intervals.
- The order of combining elements **matters**.
- The **state** depends on **interval [l, r]** (i.e., start and end indices).

```cpp
dp[l][r] = best (min/max/count) result for the subarray/subsequence from l to r.
```

Typical transition:

```cpp
for (int len = 2; len <= n; ++len) {
    for (int l = 0; l + len - 1 < n; ++l) {
        int r = l + len - 1;
        dp[l][r] = INF;
        for (int k = l; k < r; ++k) {
            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + cost(l, k, r));
        }
    }
}

```

Generally these solutions are $O(n^3$) with no optimisations 

### Matrix chain multiplication:

Given `n` matrices with dimensions such that matrix `i` is of size `a[i-1] x a[i]`, find the minimum number of scalar multiplications needed to multiply all matrices together.

`dp[l][r]` = minimum cost to multiply matrices from `l` to `r`.

Transistion:

```cpp
dp[l][r] = min(dp[l][k] + dp[k+1][r] + a[l-1]*a[k]*a[r])
```

code of this problem

```cpp
int matrixChainMultiplication(vector<int>& a) {
    int n = a.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));

    for (int len = 2; len < n; ++len) {
        for (int l = 1; l + len - 1 < n; ++l) {
            int r = l + len - 1;
            dp[l][r] = INT_MAX;
            for (int k = l; k < r; ++k) {
                int cost = dp[l][k] + dp[k+1][r] + a[l-1]*a[k]*a[r];
                dp[l][r] = min(dp[l][r], cost);
            }
        }
    }
    return dp[1][n-1];
}
```

Because we are multiplying contiguous intervals of matrices, and the result depends on how we split that interval.

### Form 5 game dp:

Games usually have some configuration or state. So given a state in any optimal game it either is win state of loose. 
From a given state player can make a move and can move to new state in this way game goes on and ends with some condition given in the problem.

Now following theorum:

```
A state is winning if and only if it leads to atleast one losing state.
```

These problems usually involve **optimal choices** and **recursion with minimax structure**.

Problem:

You are given an array `a[]` of numbers.  
Two players alternately pick numbers from either end.  
Each player plays optimally.  
Return true if the first player can win or tie.

Solution:

`dp[l][r]` = maximum score difference current player can achieve over opponent  
from subarray `[l, r]`.

Observe that for this problem top down is pretty easy to write so we are writing top down solution. Here first index is not i rather it is lenth and from length we can find the r etc.

```cpp
bool predictTheWinner(vector<int>& a) {
    int n = a.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    for (int i = 0; i < n; ++i) dp[i][i] = a[i];

    for (int len = 2; len <= n; ++len) {
        for (int l = 0; l + len - 1 < n; ++l) {
            int r = l + len - 1;
            dp[l][r] = max(a[l] - dp[l+1][r], a[r] - dp[l][r-1]);
        }
    }
    return dp[0][n-1] >= 0;
}
```

There is much more to game problems and we have discussed it here as well.


## Bitmask dp:

**Bitmask DP** is used when your state depends on **which elements of a small set (≤ 20–22)** are **already chosen or visited**.
A bitmask (an integer) encodes this subset:
- Each bit represents whether an element is included (`1`) or not (`0`).
- Example: For 5 elements, mask `10110` ⇒ elements `{1, 2, 4}` are chosen.

Use bitmask DP when:

1. You have a **small number of items (≤ 20)**.
2. You need to handle **combinations, subsets, or permutations** of those items.
3. The problem asks for **maximum/minimum/count** over such combinations.

Common use cases:

- Traveling Salesman Problem (TSP)
- Assignment / Matching
- Counting valid permutations
- Partitioning subsets (like Grouping)
- Subset convolution / covering problems
- Minimizing costs or maximizing values across subsets

### Example 1 TSP(travelling salesman problem)

Given a complete graph of `n` cities and distances `dist[i][j]`,  
find the **minimum cost Hamiltonian cycle** (visit every city exactly once and return to start).

Now brute force solution is to iterate over all the iteration `n!` solution. However we can reduce this to `O(2^n)` solution by following method.

consider `dp(i,mask) = min cost path such that we already have visited all the cities in the mask such that i was the last city to be visited`
Now solution is pretty simple we can move to one of the unvisited cities and calculate the cost.

```cpp
function<int(int,int)> rec = [&](int i,int mask){
	if(i<0)return 1;
	if(dp[i][mask]!=-1)return dp[i][mask];
	Mint ans = 0;
	for(int j=0;j<n;j++){
		if(g[i][j]==1 && (mask&(1<<j))==0){
			ans+=rec(i-1,mask|(1<<j));
		}
	}
	return dp[i][mask]=(int)ans.v;
};
```

Another use case is to do matching or maintaing certain subset. 

### Example 2 Matching

You are given an `n × n` binary matrix `a`,  
where `a[i][j] = 1` means man `i` can be matched with woman `j`.

Find the **number of perfect matchings** such that:
- Every man is matched with exactly one woman,
- Every woman is matched with exactly one man,
- Only allowed pairs (`a[i][j] = 1`) are used.

Return the result modulo `1e9+7`.

### Solution

suppose we are currently processing `mask`.  
Let `i = popcount(mask)` — the number of men already matched.

Now we try to match the next man `i` to some available woman `j`.

```cpp
function<int(int,int)> rec = [&](int i,int mask){
	if(i<0)return 1;
	if(dp[i][mask]!=-1)return dp[i][mask];
	Mint ans = 0;
	for(int j=0;j<n;j++){
		if(g[i][j]==1 && (mask&(1<<j))==0){
			ans+=rec(i-1,mask|(1<<j));
		}
	}
	return dp[i][mask]=(int)ans.v;
};
```

### Example 3 Elevator rides

There are n people who want to get to the top of a building which has only one elevator. You know the weight of each person and the maximum allowed weight in the elevator. What is the minimum number of elevator rides?

### Solution

The normal solution where we say `dp(mask) = min rides to take x people` will be `3^n`. Reason being from the mask we have to find next subset we need to take and then check if that can be taken.

Better way is to maintain a pair as solution.

`dp[mask] = (min_no_of_rides,min_wt_of_last_ride)`

Now we can move one person at a time, So we can say if ith was solved last then mask will have been `mask^(1<<i)` and if the min_wt for this is x then, we can simply take this person i with prev subset if `prev_wt+wt[i]` is under limit otherwise we need to have one more ride.

```cpp
pii dfs(int mask) {
    if (memo[mask].first != -1) return memo[mask];
    if (mask == 0) return memo[mask] = {1, 0};
    pii best = {INT_MAX, 0};
    for (int i = 0; i < n; i++) {
        if (mask & (1 << i)) {
            pii prev = dfs(mask ^ (1 << i)); // checking for prev
            pii cand;
            if (prev.second + w[i] <= x) // if we can go with prev ride
                cand = {prev.first, prev.second + w[i]};
            else
                cand = {prev.first + 1, w[i]}; // or need to take new ride strarting from here
            if (cand.first < best.first || (cand.first == best.first && cand.second < best.second)) // def of best 
                best = cand;
        }
    }
    return memo[mask] = best;
}
```

This is one of the ways to encode the state into the answer itself if answer follows a certain structure for instance here it was minimum wt. These kind of ideas can work other areas as well.

## Digit dp

Digit DP is typically used to **count numbers with constraints on digits**.

Key characteristics:
- We are counting numbers in a range `[L, R]`.
- Each position (digit) matters.
- Often involves tight constraints: is the current prefix equal to the prefix of `R`?
- Usually state looks like:

```
dp[pos][tight][other_states]
```

### Example - Count numbers ≤ N with sum of digits divisible by K

Solution: We process digits of `N` **from most significant to least significant**, keeping track of:

1. **pos** → which digit we are processing
2. **tight** → whether the prefix matches N's prefix
    - `tight = 1` → prefix so far equals N's prefix → current digit ≤ corresponding digit in N
    - `tight = 0` → `prefix < N's prefix` → current digit can go up to 9
3. **mod** → sum of digits modulo K (to track divisibility)

```cpp
long long dfs(int pos, int mod, int tight) {
    if (pos == digits.size()) return mod == 0;
    if (dp[pos][mod][tight] != -1) return dp[pos][mod][tight];
    int limit = tight ? digits[pos] : 9;
    long long ans = 0;
    for (int d = 0; d <= limit; d++) {
        int new_tight = tight & (d == limit);
        ans += dfs(pos + 1, (mod + d) % K, new_tight);
    }
    return dp[pos][mod][tight] = ans;
}
```

One important point while maintaining a number large is that any number canbe represented as 

```
y = 10*x+r; // so we can just multiply by 10 and get current so if maintaining rem only
y% k  = ((10*x)%k+r%k)%k;
```

Also when calcualting the float values always try to have visited cache for better access, otherwise it will be very bad in solution.


