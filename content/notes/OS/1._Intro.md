---
title: "1. Intro"
description: ""
date: "2026-02-05"
---



### What is an OS?

At its simplest an OS is a piece of software that controls hardware. What kind of hardware it ranges from memory ,cpu, disc and other external devices. An OS acts as abstraction for the hardware for programs. 

An OS has following important properties - 

- It is always running.
- It has more power than any other program. 

An OS is a layer that abstracts hardware complexity and presents a clean, uniform execution environment to programs. 
Now as more and more OS types came people started including lots of things with their own OS distribution for example web browser or games. 

Then we started defining the OS as OS kernel + other programs(called system programs which are associated with the OS but not part of kernel eg - A gui like GNOME). 

### Kernel 

A small, always-resident, privileged program that runs directly on the hardware and has unrestricted access to all system resources. 
Kernel is loaded at boots, runs for all time and every other program runs under its supervision. 

These must be in the kernel because they require **absolute trust**:

- CPU scheduling
- Process and thread management
- Virtual memory
- Interrupt handling
- Device drivers (in many designs)
- System call handling
- Protection and isolation

These are **safety-critical**.

An operating system consists of a kernel that manages hardware resources and enforces protection, plus a collection of system programs that run on top of the kernel.

## Modern computer design

A modern general-purpose computer system consists of one or more CPUs  and a number of device controllers connected through a common bus that provides access to shared memory.

![Pasted image 20251214151301.png](/notes-images/Pasted%20image%2020251214151301.png)


Each controller is incharge of specific type of device(disk drivers,audio devices).The CPU and the device controllers can execute in parallel,competing for memory cycles. 

Note that each device controller is a hardware component that manages specific physical device and exposes a control interface to CPU. It has many tasks such as-

- To understand device specific protocols
- Convert high level command into electrical signals.

To ensure orderly access to the shared memory,a memory controller synchronizes access to the memory. 

### CPU 

CPU is a device which can do three things repeatedly billion of times per second.

- fetch an instruction from memory
- deconde what this instruction means
- execute it

CPU has two main units inside it - 

#### Registers

These arefixed tiny storage locations inside cpu. Important CPU registers - 
- program counter
- IR(instruction register) current instruction in execution
- General purpose register
- SP (Stack pointer) - top of stack
- Flag register

So the instruction is fetched from the memory to IR and then is decoded directly by the hardware. 
#### ALU

It is again hardware unit which performs arithematic,logical and comparison operations.

#### Control unit

Control unit is what does the actual decoding it is again just a state machine at its simplest.

It - 
- Decodes instructions
- Tells ALU what to do
- Controls register read/write
- Controls memory access
- Handles interrupts

#### Caches 

CPU also contains low level caches which are very fast than memory access. 

```
Registers > L1 > L2 > L3 > RAM > Disk
```

#### Instruction cycle

Instuction cycle refers the three steps repeated billion of times per second. 

During fetch PC contains address of the instruction. It gets fetched from memory and is stored in IR. PC then increments. 

Then control unit decodes the operation meaning what to do on which registers and if there is any meory access. If that is that data needs to be loaded from memory address into some general purpose register.

Finally all the data and insturction itself is in place and CU instructs the ALU to perform the action. The result is gotten on some general purpose register and is stored back to the memory. Note that CPU might not have the unlimied access to memory memory itslef is much slower than CPU and therefore cpu needs to compete with other devices for memory access. 

Observe that all the three steps fetch , decode and ececute need different componnet of cpu and thus can be done parallelly. Infact this is called Pipelining and is the reason why cpu's are so fast. 

So instread of doing this
```
Fetch → Decode → Execute → Fetch → Decode → Execute
```

WE do this

```
Instruction 1: Fetch
Instruction 2: Decode | Instruction 1: Execute
Instruction 3: Fetch  | Instruction 2: Execute
```

#### Interrupts

Now with this setup a cpu can execute sequence of instructions. But how to stop in between.

An interupt is an instruction that stops the current execution. 

Now on interupt a hardware signal is diretly provided to the CU(control unit) of computer either by software or by hardware. Once that happens current state of CPU registers is saved and current set of execution is stopped. CPU now jumps to interupt service routine(ISR). This is another program written and runs. Once this program is completed we move towards the next step which is waking of the waiting process and then schedules the further work.

A recent trend in CPU design is to in.clude multiple computing on a single chip. In this design, each core has its own register set as well as its own local cache; other designs might use a shared cache or a combination of local and shared caches. Aside from architectural considerations, such as cache, memory, and bus contention, these multicore CPUs appear to the operating system as N standard processors.

### Main memory

CPU can only load instructions from the memory and any program which needs to run must be present in the memory. Main memory is usually called RAM(Random access memory) because each location is accessible in constant amount of time regardless of its location. 

All forms of memory provide an array of words. Each word has its own address. Interaction is achieved through a sequence of load or store instructions to specific memory addresses. The load instruction moves a word from main memory to an internal register within the CPU, whereas the store instruction moves the content of a register to main memory. Aside from explicit loads and stores, the CPU automatically loads instructions from main memory for execution.


### What happens when computer starts

For computer to start at power up it needs intial program to run. The first program to run is called bootstrap program (firmware) and is stored in ROM. These programs are wirtten by motherboard vendor and some of its emaples are BIOS and UEFI. 

Basically CPU is hardcoded to load the PC from this ROM address. Then this program starts to run. Untill this point RAM is not initialized and interupt handlers are not setup.

Now the question is why does bootstrap program exist?

When you power on a computer:

- RAM is **empty / garbage**
- Disk is **passive** (CPU cannot execute from it directly)
- OS is **not loaded**
- No processes exist

Yet the CPU must execute **some instruction**. This is why CPU is hardcoded to always load PC from ROM address and move further from there. 

Bootstrap does many things - 

- CPU reset
- CPU in kernel mode
- Intialize the cpu and memory

After intializing cpu and memory other basic hardware is setup.

Setup basic hardware
- Clock generators    
- Bus controllers    
- Chipset

Then hardware checks are done called POST

- Memory test - Checks for the addressing , timing etc. 
- CPU check 
- Device detection

Bootstrap code then checks for the bootable device meaning It looks for the device on which it can find the kernel. 
Boot device is found in - 

BIOS- 
- Disk with the boot sector
- Signature(0x55AA)
UEFI-
- FAT partition
- `.efi` executable


Note that firmware does not loads the os into memory. Rather it loads OS loader into RAM. Now this will be the first time ROM program has exited and CPU instructions are comming from RAM. Booloader now has started execution.

Different OS have differnet booloaders - 

- GRUB
- Windows Boot Manager

Now Bootloader has two main tasks 

1. Loading kernel image - This is the image of the OS in the disk
2. Placing it in the RAM. 

The key idea is this: **by the time the CPU ever executes a single kernel instruction, the entire kernel binary already lives in RAM**. The kernel will never read itself from disk.

and

1. Reads the temporary initramfs image
2. Loads it into the memory and mounts the filesystem.

Bootloader has its own disk drivers which are used to access the disk. These are simpler and not suitable for kernel use. Note that boolloader is a full program and runs from RAM unlike bootstrap/ firmware which was getting loaded from ROM.  Now once kernel is loaded into the memory bootloader is gone forever and entire control is transfered to kernel. Initially kernel can start executing as the bootloader was able to take complete kernel into memory. But soon it needs to mount root file system from disk. Accessing it requires 

- Disk controlling driver
- A filesystem driver
- Possibly drivers for encryption, RAID, or LVM

In modern systems, these drivers are **not compiled into the kernel**. They are modular, stored as files on disk, and loaded only when needed.The kernel only accesses hardware through proper kernel drivers.

Then booloader swithes the mode of CPU from `16 bit` to `32 bit` and from `real` to `long` mode. 
The bootloader performs a jump to the kernel’s entry address.

This jump is not a function call. There is no return. There is no shared stack. There is no hand-holding.

From this moment onward:
- The bootloader will never execute again
- Its memory can be overwritten

### Kernel starts 

At this point, the kernel is running, but it is still in a very fragile, half-constructed state. Many of the things we associate with an OS do not exist yet.

The first thing the kernel does is make itself stable enough to continue.

It sets up its own stack, initializes basic CPU structures, and establishes a consistent memory management system. This includes fully initializing page tables, defining which memory belongs to the kernel, and reserving regions for future allocations. At this stage, there are still no user processes, no filesystems, and no scheduling. There is exactly one flow of execution: the kernel itself.

Using the address provided by the bootloader, the kernel unpacks the initramfs archive into RAM. It then mounts this in-memory filesystem as its root directory.
This is the first time the kernel has a usable filesystem. It does not come from disk; it comes entirely from memory.
Now the kernel can finally execute user-space programs, even though it still cannot access the real disk.


Earlier, interrupts were disabled because there was nothing to handle them safely. Now the kernel has:

- Valid stacks
- Interrupt descriptor tables
- Basic memory safety
So the kernel enables interrupts.This is a turning point. From now on, hardware events like timers, disks, and keyboards can asynchronously interrupt execution. The system is no longer a simple linear program.

Up to now, only one thing has been running. To become a real OS, the kernel must support multiple execution contexts.
The kernel initializes the scheduler, creates internal kernel threads, and sets up data structures to manage processes and CPU time. Even before user programs exist, the kernel itself uses scheduling internally.

Finally, the kernel executes the program called `/init` from the initramfs. This is the first user-space process and always has process ID 1.

This process is special. It is responsible for:

- Loading disk and filesystem drivers
- Mounting the real root filesystem
- Switching from initramfs to the real system
- Starting the real init system (like `systemd`)
#### Temporary file system

The temporary filesystem called initramfs is a small file system image that the bootloader loads into RAM alongside the kernel.When the kernel starts, it mounts this in-memory filesystem as its root directory. This does not require disk access, because everything is already in RAM.

Inside this temporary filesystem are:
- Kernel modules for disk and filesystem drivers
- A minimal userspace environment
- A small program called `/init`

The purpose of this `/init` program is to 

- Load the correct disk and filesystem drivers into the kernel
- Detect the real root filesystem on disk
- Mount that real filesystem
- Switch the kernel from the temporary root to the real root

This not only means that kernel can be hardware independent as drivers are not into the kernel itself.  
Now from where does this temporary file system gets the content from when the system installs a kernel, a special tool is run (for example `initramfs-tools`, `dracut`, or `mkinitcpio`). This tool **collects exactly the files needed for early boot**, packs them together, and creates a single compressed archive. That archive is the initramfs image.


> [!NOTE] Build
> When a kernel is installed or updated, the OS runs a build process roughly like this:
   It detects which disk controller you use (NVMe, SATA, etc.) 
   It detects which filesystem your root partition uses (ext4, xfs, btrfs, etc.).
   It detects whether encryption, LVM, or RAID is involved.
   It copies the required kernel modules (`.ko` files) into a staging directory.
   It copies a minimal set of user-space tools (often from BusyBox).
   It adds a small `/init` program or script.
   It packs everything into a single archive.

This archive is written to disk in `/boot`.
Now that file system is loaded.

### Kernel continues

Now kernel has no real file system and can't see the disk in real way. So it creates its **very first user-space process**. 
This process is special not because it has more privilege — it still runs in Ring 3 like any other user program — but because **the kernel’s survival depends on it**. If this process dies, the kernel panics. There is nothing else to fall back on. This process starts inside a tiny, temporary filesystem already loaded into RAM along with the kernel. This filesystem is called **initramfs**. 

Inside this initramfs lives a small program — often `/init` — and the kernel hands control to it.

At this point, the kernel itself does not know how to talk to your storage device in a high-level way. It has no idea how to interpret partitions, filesystems, or disk layouts. That knowledge lives in **drivers and filesystem code**, many of which are not built directly into the kernel image. They exist as loadable modules.

So this first process starts **loading disk and filesystem drivers**. It pulls in the modules needed to talk to your hardware

Once the kernel can talk to the disk and understand the filesystem format, the process moves to the next critical step: **finding and mounting the real root filesystem**.

Until now, `/` has been fake — a temporary filesystem living entirely in RAM. The init process locates the real root device, often specified by a UUID or label, and asks the kernel to mount it. Suddenly, the real system appears: the actual `/etc`, `/bin`, `/lib`, `/usr`, and everything that makes the machine feel permanent rather than improvised. 

The kernel is running, the real root filesystem is mounted, but the process itself is still executing from initramfs. So the process performs one of the most delicate operations in the entire boot sequence: **switching from initramfs to the real root filesystem** by performing the operation `switch_root`. 

It tells the kernel: “From now on, this new filesystem is `/`.” Now the responsibilty of init is done and kernel will start the real init system usually systemd 

The kernel hands over the role of “process number one” to this init system. From here on, the machine becomes fully alive. `systemd` begins spawning services, setting up networking, starting daemons, mounting additional filesystems, and eventually bringing up login prompts and graphical environments. `systemd` is not “just a service starter”. It is the **userspace manager of the entire system**.

### Security ring model 

To enforce this trust, the CPU divides the world into **concentric rings**, like layers around a castle. The closer you are to the center, the more power you have. The farther out you are, the more you’re restricted. These are called **security rings**, and on x86 systems there are four of them: Ring 0 to Ring 3.

At the very center of the castle is **Ring 0**. This is sacred ground. Only the **kernel** is allowed here. Code running in Ring 0 can do absolutely anything the hardware allows. It can touch any memory address, talk directly to devices, reprogram the CPU, enable or disable interrupts, change page tables, and even crash the entire machine if it makes a mistake. When Linux, Windows, or any modern OS kernel runs, it runs here. This is why kernel bugs are catastrophic and why kernel code is kept small and carefully guarded.

Now move one step outward. Historically, CPUs defined **Ring 1 and Ring 2** as intermediate layers. The idea was that maybe device drivers or OS services could live here—trusted, but not as powerful as the kernel itself. In practice, modern operating systems mostly ignore these rings. Maintaining multiple privilege layers turned out to be complex and not worth the trouble. So today, Ring 1 and Ring 2 exist more as architectural ghosts than active participants in the story.

Then you reach the outer wall: **Ring 3**. This is where **user programs live**—your browser, your editor, your games, your code. Ring 3 is a sandbox. Code running here is deliberately powerless. It cannot access hardware directly. It cannot touch kernel memory. It cannot halt the CPU, change page tables, or talk to a disk controller. If it tries, the CPU immediately intervenes and raises a fault.

But user programs still need things. They need files, memory, network access, timers, and devices. So how do they cross the wall without breaking it?

When a program in Ring 3 needs help, it doesn’t jump into Ring 0 directly. That would be illegal. Instead, it uses a **special instruction* like `syscall` or `sysenter` which tells the CPU:  

“I am requesting a controlled entry into the kernel.”

The CPU pauses the user program, switches privilege level from Ring 3 to Ring 0, jumps to a carefully chosen kernel entry point, and now the kernel runs **on behalf of** the user program. The kernel checks permissions, validates arguments, does the work safely, and then returns control back to Ring 3. The wall stays intact, and order is preserved.
