---
title: "8.Deadlocks"
description: ""
date: "2026-02-05"
---



A process requests resources; if the resources are not available at that time, the process enters a waiting state. Sometimes, a
waiting process is never again able to change state, because the resources it has requested are held by other waiting processes. This situation is called a deadlock.

A Computer system consists  of finite number of resources to be distributed among competing process.  A process must request a resource before using it and must release the resource after using it. A process may request as many resources as it requires to carry out its designated task.

Resources are requested and alloted through system calls such as allocate() and free(). A set of processes is in a deadlocked state when every process in the set is waiting for an event that can be caused only by another process in the set.The resources may be either physical resources (for example, printers,tape drives, memory space, and CPU cycles) or logical resources (for example,semaphores, mutex locks, and files).

Deadlocks may also involve different resource types. For example, consider a system with one printer and one DVD drive. Suppose that process Pi is holding the DVD and process P j is holding the printer. If Pi requests the printer and P j requests the DVD drive, a deadlock occurs.

### Necessary conditions of deadlock

A deadlock situation can arise if the following four conditions hold simultaneously in a system:

- Mutual exclusion-At least one resource must be held in a nonsharable mode; that is, only one process at a time can use the resource. If another process requests that resource, the requesting process must be delayed until the resource has been released.
- Hold and wait. A process must be holding at least one resource and waiting to acquire additional resources that are currently being held by other processes.
- No preemption. Resources cannot be preempted; that is, a resource can be released only voluntarily by the process holding it, after that process has completed its task. 
- Circular wait. A set $\{P0 , P1 , ..., Pn \}$ of waiting processes must exist such that P0 is waiting for a resource held by P1 , P1 is waiting for a resource held by P2 , ..., Pn−1 is waiting for a resource held by Pn , and Pn is waiting for a resource held by P0 .

### Resource allocation graph

Resource alocation graph has two kinds of nodes one for processes(P) and other for resources (R). A directed edge from Process node to resource node signifies that process has requested resource(request edge). And directed edge from resource to process signifies that resource has been assigned to process(assignement edge). Pictorially, we represent each process `P[i]` as a circle and each resource type `R[j]` as a rectangle.

Given the definition of a resource-allocation graph, it can be shown that, if the graph contains no cycles, then no process in the system is deadlocked. If the graph does contain a cycle, then a deadlock may exist. In the case of all the resources in graph have only one instance then cycle existance is both the necessary and sufficient condition for the existance of deadloack. In case of multiple instance of resources cycle is necessary but not the sufficient condition. 

### Dealing with deadlocks

1. Use algorithms that ensure system never enters a deadlock state. 
2. Detect deadlock state , detect it and recover from it. 
3. Ignore the deadlock.

The third solution is the one used by most operating systems, including Linux  and Windows. It is then up to the application developer to write programs that handle deadlocks.

Deadlock prevention provides a set of methods to ensure that at least one of the necessary conditions  cannot hold. These methods prevent deadlocks by constraining how requests for resources can be made.
Deadlock avoidance requires that the operating system be given additional information in advance concerning which resources a process will request and use during its lifetime. With this additional knowledge, the operating system can decide for each request whether or not the process should wait.

### Deadlock prevention

Mutual exclusion can not be prevented as in any system resources will be shared. 

Second is hold and wait- One protocol to avoid hold and wait is to allocate all the resources needed by the system before it begins execution. An alternative protocol allows a process to request resources only when it has none. A process may request some resources and use them. Before it can request any additional resources, it must release all the resources that it is currently allocated. Both of ideas have flaws that resource utilization is low. Second starvation is possible. 

Third condition is preemption -One protocol to avoid this is to check if the required resources are available if not release all the resources. This protocol is often applied to resources whose state can be easily saved and restored later, such as CPU registers and memory space.

Fourth is circular wait - One way to ensure that this condition never holds is to impose a total ordering of
all resource types and to require that each process requests resources in an increasing order of enumeration. It means if resource with lesser number is requested all the resources with larger number must be released. 
Disadvantages – low resource utilization, reduced throughput.

### Deadlock avoidance

An alternative method for avoiding deadlocks is to require additional information about how resources are to be requested. With this information before hand os can decide if any process should wait to avoid deadlock.

The process will declare the max number of instances of each resource type to the os. A deadlock-avoidance algorithm dynamically examines the resource-allocation state to ensure that a circular-wait condition can never exist. The resource-
allocation state is defined by the number of available and allocated resources and the maximum demands of the processes.

#### Safe state

A state is safe if the system can allocate resources to each process (up to its maximum) in some order and still avoid a deadlock. A seqeunce of process `<P1,P2...>` is called a safe sequence for the current allocation if, for each process `Pi` the resource request that `Pi` can still make be satisfied by currently available resources plus resources held by all `Pj` where `j<i`. In this situation, if the resources that `Pi` needs are not immediately available, then `Pi` can wait until all `Pj` have finished.

A safe state is not a deadlocked state. Conversely, a deadlocked state is an unsafe state. Not all unsafe states are deadlocks, however (Figure 7.6). An unsafe state may lead to a deadlock. As long as the state is safe, the operating system can avoid unsafe (and deadlocked) states. In an unsafe state, the operating system cannot prevent processes from requesting resources in such a way that a deadlock occurs. The behavior of the processes controls unsafe states.

### Resource allocation graph algorithm

### Banker algorithm

### Deadlock detection

Wait for graph has one type of nodes process nodes `Pi to Pj` edge is there if and only if `Pi` is waiting for the `Pj` to release the resources `Pi` needs. Clearly deadlock is there if there is cycle in the graph. Idea is to run cycle detection prediodically to detect deadlock. 

### Recovery from deadlock

