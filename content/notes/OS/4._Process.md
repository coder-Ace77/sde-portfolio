# 4. Process

---

A program is just a set of instructions stored somewhere. Process is program in execution. A process is the unit of work in a modern time-sharing system.

Now having multiple process in the memory and allowing all of them to procede at once called multiprogramming has benefits in case of multiprocessor environment as all of them can procede. However they are also better in case of single processor reason being a process is not always executing on cpu but also needs io so allowing other process to be executed at this time means better resource utilization.

In a batch environment a process is called a job which is a long running process where as time shared system has user programs/task.

Keeping all of that in mind Process still is the program in execution. A process is a physical entity and therefore has components.

### Process sections

The program code is called text section.

The process contains the current activity represented by the valueof program counter and content of processor's register.

A process generally also includes the process stack, which contains temporary data (such as function parameters, return addresses, and local variables), and a data section, which contains global variables. A process may also include a heap, which is memory that is dynamically allocated during process run time.

![Alt](/img/Pasted_image_20251216140852.png)

So at this point understand that program is stored as the passive entity in the disk and when it is put in the memory by OS it becomes active. OS is reponsible for allocating the resource(memory) to a process and making all the sections. The entire process in turn is kept by the OS itself as well.

### Process state-

As a process executes, it changes state. Following are the states of a process -

- New - The process is being created.
- Running - Instructions being executed
- Waiting - The process is waiting for some event to occur.
- Ready - Process is waiting to get assigned to processor.
- Terminated - Finished execution

![Alt](/img/Pasted_image_20251216141315.png)

### Process control block

Each process is represented in the operating system by a process control block (PCB)—also called a task control block. Actually it is the physical representation of process by the OS. Or it can also be visualised as the data structure.

In addition of earlier represented program section is contains -

- Process state
- Memory-management information. This information may include such items as the value of the base and limit registers and the page tables
- Accounting information. This information includes the amount of CPU and real time used, time limits, account numbers, job or process numbers, and so on.
- I/O status information. This information includes the list of I/O devices allocated to the process, a list of open files, and so on.
- Process number or a unique process identifier called pid.

![Alt](/img/Pasted_image_20251216141722.png)

Note that PCB does not contains the stack , heap or data sections. It just contains the memory limit aka start and limit registers.

In brief, the PCB simply serves as the repository for any information that may vary from process to process.

### Threads

In earlier computers one process could do only one task at a time. Today's computers can do multiple tasks inside a process at a given time. Each independent unit of task execution is called thread of execution or simple thread.

### Process scheduling

The task of process scheduler is to select an available process for the program execution on CPU.

##### Scheduling queues

As processes enter the system, they are put into a **job queue**, which consists of all processes in the system.

The processes that are residing in main memory and are ready and waiting to execute are kept on a list called the **ready queue**.This queue is generally stored as a linked list. A ready-queue header contains pointers to the first and final PCBs in the list. Each PCB includes a pointer field that points to the next PCB in the ready queue.

There are other queues as well for example device queue meaning which process are waiting to get the device like printer etc.

![Alt](/img/Pasted_image_20251216142805.png)

A new process is initially put in the ready queue. It waits there until it is selected for execution, or dispatched.
A process moves from various queues during its lifecycle.

Degree of multiprogramming - The **degree of multiprogramming** is the **number of processes that are resident in main memory and ready to execute at the same time**.

`Short Term scheduler` or `dispatcher` selects the process from ready queue to Running. It works on ready processes and runs very frequently. It controls the response time, CPU utilisation and throughput.

Long term scheduler or job scheduler decides which processes are admitted to the system. It is schene in batch processing systems where jobs are put on the system. `Job schedulers` will load the process from job pool and load it into memory. Moves process from `NEW to READY` state and runs rarely and controls the degree of **multiprogramming**.

Medium term scheduler - Manages **memory pressure by suspending/resuming processes**. It also runs occasionally and controls degree of multiprogramming. Example - Swapping out a process to disk when RAM is low and bringing it back later.

Note that Long term scheduler decides the which process will come into memory which means it decides which set of process will be running at the same time. Long term scheduler must do the selection casefully.

A cpu bound process is one which will be running on cpu most of its time and will wait for i/o only for small time. An i/o bound process takes most of its time eaiting for i/o rather than running on cpu. Job scheduler must select the set of process such that its a good mix of both i/o running and cpu bound.

### Context switching

When the process currently running goes into `READY` state or an interupt is called. The system needs to save the current `context` of process running into a PCB. Generically, we perform a state save of the current state of the CPU, be it in kernel or user mode, and then a state restore to resume operations.

Switching the CPU to another process requires performing a state save of the current process and a state restore of a different process. This task is known as a context switch.

Context switching is pure overhead is system is not doing usefull work during this time.

### Interservice communication

Interprocess Communication (IPC) refers to the mechanisms provided by an operating system that allow **independent processes to exchange data and coordinate their actions**.

IPC mechanisms are broadly classified into **shared-memory–based** and **message-passing–based** approaches.

In shared memory IPC, the operating system establishes a region of memory that is mapped into the address space of multiple processes. Once this region is created, processes can communicate by reading from and writing to the shared area, making this method very fast as it avoids kernel involvement after setup. However, shared memory requires explicit **synchronization mechanisms** such as semaphores or mutexes to prevent race conditions and ensure data consistency. So here we deal with bounded buffer problem.

Message passing IPC enables processes to communicate by sending and receiving messages through the operating system. This approach does not require shared address spaces and is therefore easier to use in distributed environments. Message passing can be implemented using mechanisms such as **pipes, message queues, sockets, and signals**. Although it involves more kernel overhead than shared memory, it provides better isolation and simpler synchronization, as the operating system handles message delivery.
