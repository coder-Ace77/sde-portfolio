---
title: "2. Linux booting log"
description: ""
date: "2026-02-05"
---



Power button is pressed.

Nothing from Linux yet. The CPU wakes up in a very primitive state and immediately jumps to a hard-wired address in ROM. That’s why the very first visible line (if you could see it) is something like:

`BIOS version 2.15.0`

This line belongs to **firmware execution**. The CPU hasn’t touched disk, RAM is barely usable, and the firmware is running from ROM. At this moment the firmware probes memory, checks basic hardware, and decides which disk to boot from.

Then you’ll see something like:

`Booting from Hard Disk...`

This single line is extremely important. It means firmware has finished its job and is about to load **exactly 512 bytes** from the disk into memory — the bootloader’s first stage.

Immediately after, GRUB takes over and the screen changes completely. Now you might see:

`GRUB loading.`  
`Welcome to GRUB!`

This is **Step 6: Bootloader loads the OS** beginning. GRUB is no longer firmware; it’s a real program living on disk. GRUB now knows filesystems, can read ext4, and can load large files.

Then GRUB prints something like:

`Loading Linux 6.5.0-18-generic ...`  
`Loading initial ramdisk ...`

These two lines map cleanly to **“Loads kernel image”** and **“Loads initramfs”**. The kernel image (`vmlinuz`) is decompressed into memory, and the initramfs is placed beside it so the kernel can use it as a temporary root filesystem.

At this point, control jumps from GRUB to the kernel. The very first kernel line usually looks like:

`Linux version 6.5.0-18-generic (buildd@lcy02-amd64-012)`

This line marks the **exact instant the kernel gains control**. GRUB is gone forever. The kernel is executing directly on the CPU now.

Immediately after, you’ll see:

`Command line: BOOT_IMAGE=/vmlinuz root=/dev/sda1 ro quiet splash`

This is the kernel reading arguments passed by the bootloader. This belongs to the same bootloader step, specifically **“Jumps to kernel entry point with parameters.”**

Now the kernel begins serious work. You’ll see:

`x86: Booting SMP configuration`

This line tells you the kernel is initializing CPU cores. This is part of **kernel initialization**, not bootloader anymore.

Then something like:

`Memory: 16324872K/16777216K available`

This line corresponds to **RAM initialization**. The kernel is discovering usable memory regions and setting up its internal memory manager.

Next comes:

`Calibrating delay loop... 5199.98 BogoMIPS`

This belongs to **CPU setup**. The kernel is figuring out how fast the CPU runs so timing works correctly.

Now paging appears:

`Initializing cgroup subsys cpuset`  
`Initializing cgroup subsys cpu`

These lines only make sense after:

`Kernel command line:`  
`Setting up paging and virtual memory`

This is the kernel **setting up page tables** and enabling virtual memory. From this point onward, Linux no longer thinks in physical addresses — everything is virtual.

Then comes the most critical moment:

`Enabling interrupts`

Sometimes this line is implicit, sometimes explicit, but this marks the transition from a single-threaded, deterministic kernel to an **interrupt-driven system**. Hardware can now interrupt the CPU. This maps exactly to **“Enables interrupts.”**

Immediately after, hardware starts talking back:

`PCI: Using configuration type 1`  
`usbcore: registered new interface driver usbfs`

This is **hardware discovery via interrupts**. Devices are now alive and responding.

Now the kernel mounts the temporary filesystem:

`Mounting root filesystem`

This refers to the **initramfs** that was loaded earlier by GRUB. The kernel is executing `/init` from initramfs now.

Then you’ll see:

`Run /init as init process`

This line is the bridge between kernel space and user space. The kernel has finished its internal setup and is about to start the first user process.

Then suddenly:

`systemd[1]: systemd 252 running in system mode`

This line maps perfectly to **“Launches first process (init / systemd)”**. Process ID 1 is now running. If PID 1 dies, the system dies. This is the true birth of user space.

Immediately systemd starts the scheduler-driven chaos:

`systemd[1]: Detected architecture x86-64`  
`systemd[1]: Mounted /proc`  
`systemd[1]: Mounted /sys`

These lines indicate that the **scheduler is fully active**, multitasking is real, and multiple processes are now running concurrently.

Then devices appear:

`systemd-udevd[312]: Starting device manager`

This maps to **device drivers and user-space hardware management** taking over from the kernel.

Finally, something like:

`Reached target Graphical Interface`  
or  
`Reached target Multi-User System`

This is the completion of **OS taking control**. The bootstrap phase is officially done. The system is now fully operational, scheduling processes, handling interrupts, responding to keyboard and mouse events, and running applications.

From pressing the power button to this moment, control moved like a baton in a relay race: **firmware → bootloader → kernel → initramfs → systemd → user processes**. Each log line you saw was not noise — it was a breadcrumb showing exactly who was in charge at that moment and what responsibility they were completing.

If you want, next we can take **an actual `dmesg` log from your system** and annotate it line-by-line in the same storytelling style — that’s where this really becomes.

