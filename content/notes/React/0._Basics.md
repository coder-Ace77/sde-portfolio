---
title: "0. Basics"
description: ""
date: "2026-02-05"
---



The code that we write as developer in react is not the code that is executed in browser. Rather the code we write is fundamentally not understood by browser. So the code is transformed into normal javascript code before being given to browser. React process use build process and if we create the applications using the create-react-app or say vite. Then all of them come with build tools. 

In react this is actually `react-scripts` dependency which handles the code behind the schenes. In the local environment development server handles the conversion.  

## Inport and export

1. We can use export keyword export before any entiry to make it available to any other file. These are also called named exports as the variable name used in other files needs to match with the current variable. 

```js
export const api_key = "abcdefghi";
```

Now importing

```js
import {api_key} from "./utils.js";
```

Now, api_key is available as global variable. 

We can also create a default export where the name is not assigned rather directly value is exported. A file can have atmost one default export. Default exports can be imported by any name.

```js
export default "abcdefghi";

or 

const x = ()=>{
}

export default x;
```

importing default export 

```js
import x from "./utils.js";
```

Finally we can have multiple named exports in a file and we can import all the named exports in another file as one object. As can be used to aliasing the variables. 

```js
import * as util from "./utils.js";
console.log(util.x()); 
```

```js
import {abc as x} from "./utils.js";
```

## React 

React is used to create the applications using declarative method. Code written inside .js/jsx file is seen by the build tool and built into valid js code using build tools such as vite. 

A **React component** is a **reusable piece of UI** — a small, independent, and isolated part of a web page that decides **what to display and how it behaves**.

You can think of it like a **function that returns HTML** (actually JSX). JSX is simply the html inside javascript. 

There are mainly two kinds of components-

1. functional - 
2. Class components (older)

props - Props are **inputs** to a component — like parameters in a function.

```jsx
function Greeting(props) {
  return <h2>Hello, {props.name}!</h2>;
}

<Greeting name="Adil" />  // passes prop 'name' = 'Adil' we can pass the entire objects and it will be accessible to the component as fields of props. 
```

Alternatively we can desturcture the props object

```jsx
function Greeting({name,type="button"}){
	return (<h2>
		Hello world
	</h2>);
}
```

images can be imported using import statement and images. 

```jsx
import reactImg from './path';


// usage 
<img src={reactImg}/>
```

There is a special built in children prop used to get the children of a component. 

```jsx
export default function Tab(props){
	return (
		<div>{props.children}</div>
	);
}

// passing 
<Tab>Hello there</Tab>
```

Alternative label way

```jsx
<Tab label="Component"></Tab>

function Tab({label}){
	return (<div>{label}</div>);
}
```

We can react to events using passing the functions to the props 

```jsx
function Mycomp(){
	return (
		<div> 
			<button onClick={onClickHandler}>Hi</button>
		</div>
	);
	
}
```

So all the button divs etc are special components created in react  by default. These components have many buildin props which we can pass the values to. 

In jsx we can add the inline css syling by using className prop

```jsx
<button className="">Hello</button>
selected = "color: green";
unselected = "color: red";
<button className={isSelected?seleted:unselected}>Hello</button>
```

Note that styling can be defined conditionally since the passed prop must be a javascript expression which returns a valid string corresponding to a given styling. 

We don't need to use jsx and build tool to create the create application rather we can use the 

```js
React.createElement('div', {
	id:'content'
},
React.createElement('p',null,'Hello world')
)
```

## Fragments

Each component must return the valid tree which has exactly one root. We can use fragment instead. There was earlier way where we had to import Fragment from react. Now we can simply add `<></>` 

```
import {Fragment} from 'react';

const MyComp(){
	return (
		<>
			<div></div>
			<div></div>
		</>
	);
}

```

Think of **slots** as **places inside a component** where you can **insert JSX from the parent**.

In React, these “slots” are usually implemented using the **`children` prop** or **custom render props**.By default, a component can receive **only one** special prop called `children`.But sometimes, you want **multiple specific slots** — like a header, body, and footer.

```jsx
<Modal
  header={<h1>Title</h1>}
  body={<p>Modal content...</p>}
  footer={<button>Close</button>}
/>
```

Solution1

```jsx
function Modal({ header, body, footer }) {
  return (
    <div className="modal">
      <div className="header">{header}</div>
      <div className="body">{body}</div>
      <div className="footer">{footer}</div>
    </div>
  );
}

// Usage
<Modal
  header={<h1>Welcome</h1>}
  body={<p>This is a multi-slot modal.</p>}
  footer={<button>Close</button>}
/>
```

Images and public assets can be stored inside the public folder and these are made available publically by the underlying project developement server and build process. So any image put in public folder is accessible by the normal user via url. 

You can also store images in the `src/assets/` folder (or, actually, anywhere in the `src` folder).

So what's the difference compared to `public/`?

Any files (of any format) stored in `src` (or subfolders like `src/assets/`) are **not made available to the public**. They can't be accessed by website visitors. If you try loading `localhost:5173/src/assets/some-image.jpg`, you'll get an error.

Instead, files stored in `src/` (and subfolders) can be used in your code files. Images imported into code files are then picked up by the underlying build process, potentially optimized, and kind of _"injected"_ into the `public/` folder right before serving the website. Links to those images are automatically generated and used in the places where you referenced the imported images.

If you are updating the state based on the previous state we should update the update using function 

```js
setUpdate((prev_state)=>{
	// logic which yields current_state
	return current_state;
})
```

This is recommended way of doing. 

Two way binding in input fields. This is done to bind the value of state to some input field. 

```jsx
<input type="text" onChange={handleChange} value={inputState}>
```

Lifting the state up :

We try to maintain the state in the state in parent of component. And the child component now takes the current state as prop